<html lang="en">
<head>
<title>Global variables - MIT/GNU Scheme 9.0</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Efficiency-Tips.html#Efficiency-Tips" title="Efficiency Tips">
<link rel="prev" href="Coding-style.html#Coding-style" title="Coding style">
<link rel="next" href="Fixnum-arithmetic.html#Fixnum-arithmetic" title="Fixnum arithmetic">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents the use of MIT/GNU Scheme 9.0.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Global-variables"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Fixnum-arithmetic.html#Fixnum-arithmetic">Fixnum arithmetic</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Coding-style.html#Coding-style">Coding style</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Efficiency-Tips.html#Efficiency-Tips">Efficiency Tips</a>
<hr>
</div>

<h4 class="subsection">4.3.2 Global variables</h4>

<p><a name="index-variable-caches-153"></a><a name="index-reference-traps-154"></a>Compiled code usually accesses variables in top-level first-class
environments via <em>variable caches</em>.  Each compiled procedure has a
set of variable caches for the global variables that it uses.  There are
three kinds of variable cache&mdash;read caches for getting the value of a
variable (referencing the variable), write caches for changing the
value, and execute caches for calling the procedure assigned to that
variable.

   <p>Sometimes the variable caches contain special objects, called reference
traps, that indicate that the operation cannot proceed normally and
must either be completed by the system (in order to keep the caches
coherent) or must signal an error.  For example, the assignment

<pre class="example">     (set! newline my-better-newline)
</pre>
   <p>will cause the system to go to each compiled procedure that calls
<code>newline</code> and update its execute cache to call the new procedure. 
Obviously you want to avoid updating hundreds of execute caches in a
critical loop.  Using <code>fluid-let</code> to temporarily redefine a
procedure has the same inefficiency (but twice!).

   <p>To behave correctly in all situations, each variable reference or
assignment must check for the reference traps.

   <p>Sometimes you can prove that the variable (a) will always be bound, (b)
will never be unassigned, and (c) there will never be any compiled calls
to that variable.  The compiler can't prove this because it assumes that
other independently compiled files might be loaded that invalidate these
assumptions.  If you know that these conditions hold, the following
declarations can speed up and reduce the size of a program that uses
global variables.

<div class="defun">
&mdash; declaration: <b>ignore-reference-traps</b><var> variables<a name="index-ignore_002dreference_002dtraps-155"></a></var><br>
<blockquote><p>This declaration tells the compiler that it need not check for
reference-trap objects when referring to the given <var>variables</var>. 
If any of the <var>variables</var> is unbound or unassigned then a variable
reference will yield a reference-trap object rather than signaling an
error.  This declaration is relatively safe: the worst that can happen
is that a reference-trap object finds its way into a data structure
(e.g. a list) or into interpreted code, in which case it will probably
cause some `unrelated' variable to mysteriously become unbound or
unassigned. 
</p></blockquote></div>

<div class="defun">
&mdash; declaration: <b>ignore-assignment-traps</b><var> variables<a name="index-ignore_002dassignment_002dtraps-156"></a></var><br>
<blockquote><p>This declaration tells the compiler that it need not check for
reference-trap objects when assigning to the given <var>variables</var>.  An
assignment to a variable that ignores assignment traps can cause a great
deal of trouble.  If there is a compiled procedure call anywhere in the
system to this variable, the execute caches will not be updated, causing
an inconsistency between the value used for the procedure call and the
value seen by reading the variable.  This mischief is compounded by the
fact that the assignment can cause other assignments that were compiled
with checks to behave this way too. 
</p></blockquote></div>

   <p>The <var>variables</var> are specified with expressions from the following
set language:

<div class="defun">
&mdash; variable-specification: <b>set</b><var> name <small class="dots">...</small><a name="index-set-157"></a></var><br>
<blockquote><p>All of the explicitly listed names. 
</p></blockquote></div>

<div class="defun">
&mdash; variable-specification: <b>all</b><var><a name="index-all-158"></a></var><br>
&mdash; variable-specification: <b>none</b><var><a name="index-none-159"></a></var><br>
&mdash; variable-specification: <b>free</b><var><a name="index-free-160"></a></var><br>
&mdash; variable-specification: <b>bound</b><var><a name="index-bound-161"></a></var><br>
&mdash; variable-specification: <b>assigned</b><var><a name="index-assigned-162"></a></var><br>
<blockquote><p>These expressions name sets of variables. <code>all</code> is the set of all
variables, <code>none</code> is the empty set, <code>free</code> is all of the
variables bound outside the current block, <code>bound</code> is all of the
variables bound in the current block and <code>assigned</code> is all of the
variables for which there exists an assignment (i.e. <code>set!</code>). 
</p></blockquote></div>

<div class="defun">
&mdash; variable-specification: <b>union</b><var> set1 set2<a name="index-union-163"></a></var><br>
&mdash; variable-specification: <b>intersection</b><var> set1 set2<a name="index-intersection-164"></a></var><br>
&mdash; variable-specification: <b>difference</b><var> set1 set2<a name="index-difference-165"></a></var><br>
<blockquote>
        <p>For example, to ignore reference traps on all the variables except
<var>x</var>, <var>y</var> and any variable that is assigned to

     <pre class="example">          (declare (ignore-reference-traps
                    (difference all (union assigned (set x y)))))
</pre>
        </blockquote></div>
   <!-- Note: The scoping of @code{ignore-reference-traps} and -->
<!-- @code{ignore-assignment-traps} differs between version of the -->
<!-- compiler.  MIT/GNU Scheme version 8.0 (Liar version 5.0) has -->
<!-- true block scoping, thus the declaration takes effect only within the -->
<!-- procedure or @code{let} in which the declaration occurs.  This makes -->
<!-- it possible to control individual variable references, for example: -->
<!-- @example -->
<!-- @group -->
<!-- (let () -->
<!-- (declare (ignore-reference-traps x)) -->
<!-- x) -->
<!-- @end group -->
<!-- @end example -->
<!-- In earlier versions, a declaration affects all uses of the variable. -->
<!-- In all versions, top level declarations affect the whole source file. -->

   </body></html>

