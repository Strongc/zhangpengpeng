<html lang="en">
<head>
<title>Lambda Expressions - MIT/GNU Scheme 9.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Special-Forms.html#Special-Forms" title="Special Forms">
<link rel="prev" href="Special-Forms.html#Special-Forms" title="Special Forms">
<link rel="next" href="Lexical-Binding.html#Lexical-Binding" title="Lexical Binding">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents MIT/GNU Scheme 9.0.1.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Lambda-Expressions"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Lexical-Binding.html#Lexical-Binding">Lexical Binding</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Special-Forms.html#Special-Forms">Special Forms</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Special-Forms.html#Special-Forms">Special Forms</a>
<hr>
</div>

<h3 class="section">2.1 Lambda Expressions</h3>

<div class="defun">
&mdash; special form: <b>lambda</b><var> formals expression expression <small class="dots">...</small><a name="index-lambda-178"></a></var><br>
<blockquote><p><a name="index-lambda-expression-_0028defn_0029-179"></a><a name="index-procedure_002c-construction-180"></a><a name="index-procedure_002c-closing-environment-_0028defn_0029-181"></a><a name="index-procedure_002c-invocation-environment-_0028defn_0029-182"></a><a name="index-construction_002c-of-procedure-183"></a><a name="index-closing-environment_002c-of-procedure-_0028defn_0029-184"></a><a name="index-invocation-environment_002c-of-procedure-_0028defn_0029-185"></a><a name="index-environment_002c-of-procedure-186"></a><a name="index-environment_002c-procedure-closing-_0028defn_0029-187"></a><a name="index-environment_002c-procedure-invocation-_0028defn_0029-188"></a>A <code>lambda</code> expression evaluates to a procedure.  The environment in
effect when the <code>lambda</code> expression is evaluated is remembered as
part of the procedure; it is called the <dfn>closing environment</dfn>.  When
the procedure is later called with some arguments, the closing
environment is extended by binding the variables in the formal parameter
list to fresh locations, and the locations are filled with the arguments
according to rules about to be given.  The new environment created by
this process is referred to as the <dfn>invocation environment</dfn>.

        <p><a name="index-region-of-variable-binding_002c-lambda-189"></a><a name="index-variable-binding_002c-lambda-190"></a>Once the invocation environment has been constructed, the
<var>expression</var>s in the body of the <code>lambda</code> expression are
evaluated sequentially in it.  This means that the region of the
variables bound by the <code>lambda</code> expression is all of the
<var>expression</var>s in the body.  The result of evaluating the last
<var>expression</var> in the body is returned as the result of the procedure
call.

        <p><a name="index-lambda-list-_0028defn_0029-191"></a><a name="index-parameter-list_002c-of-lambda-_0028defn_0029-192"></a><a name="index-formal-parameter-list_002c-of-lambda-_0028defn_0029-193"></a><var>Formals</var>, the formal parameter list, is often referred to as a
<dfn>lambda list</dfn>.

        <p>The process of matching up formal parameters with arguments is somewhat
involved.  There are three types of parameters, and the matching treats
each in sequence:

          <dl>
<dt>Required<dd>All of the <dfn>required</dfn> parameters are matched against the arguments
first.  If there are fewer arguments than required parameters, an error
of type <code>condition-type:wrong-number-of-arguments</code> is signalled;
this error is also signalled if there are more arguments than required
parameters and there are no further parameters. 
<a name="index-required-parameter-_0028defn_0029-194"></a><a name="index-parameter_002c-required-_0028defn_0029-195"></a><a name="index-condition_002dtype_003awrong_002dnumber_002dof_002darguments-196"></a>
<br><dt>Optional<dd>Once the required parameters have all been matched, the <dfn>optional</dfn>
parameters are matched against the remaining arguments.  If there are
fewer arguments than optional parameters, the unmatched parameters are
bound to special objects called <dfn>default objects</dfn>.  If there are
more arguments than optional parameters, and there are no further
parameters, an error of type
<code>condition-type:wrong-number-of-arguments</code> is signalled. 
<a name="index-optional-parameter-_0028defn_0029-197"></a><a name="index-parameter_002c-optional-_0028defn_0029-198"></a><a name="index-default-object-_0028defn_0029-199"></a><a name="index-condition_002dtype_003awrong_002dnumber_002dof_002darguments-200"></a>
<a name="index-default_002dobject_003f-201"></a>The predicate <code>default-object?</code>, which is true only of default
objects, can be used to determine which optional parameters were
supplied, and which were defaulted.

          <br><dt>Rest<dd>Finally, if there is a <dfn>rest</dfn> parameter (there can only be one), any
remaining arguments are made into a list, and the list is bound to the
rest parameter.  (If there are no remaining arguments, the rest
parameter is bound to the empty list.) 
<a name="index-rest-parameter-_0028defn_0029-202"></a><a name="index-parameter_002c-rest-_0028defn_0029-203"></a>
In Scheme, unlike some other Lisp implementations, the list to which a
rest parameter is bound is always freshly allocated.  It has infinite
extent and may be modified without affecting the procedure's caller. 
</dl>

        <p><a name="index-g_t_0023_0021optional-204"></a><a name="index-g_t_0023_0021rest-205"></a>Specially recognized keywords divide the <var>formals</var> parameters into
these three classes.  The keywords used here are &lsquo;<samp><span class="samp">#!optional</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">.</span></samp>&rsquo;, and &lsquo;<samp><span class="samp">#!rest</span></samp>&rsquo;.  Note that only &lsquo;<samp><span class="samp">.</span></samp>&rsquo; is defined by
standard Scheme &mdash; the other keywords are MIT/GNU Scheme extensions. 
&lsquo;<samp><span class="samp">#!rest</span></samp>&rsquo; has the same meaning as &lsquo;<samp><span class="samp">.</span></samp>&rsquo; in <var>formals</var>.

        <p>The use of these keywords is best explained by means of examples.  The
following are typical lambda lists, followed by descriptions of which
parameters are required, optional, and rest.  We will use &lsquo;<samp><span class="samp">#!rest</span></samp>&rsquo;
in these examples, but anywhere it appears &lsquo;<samp><span class="samp">.</span></samp>&rsquo; could be used
instead.

          <dl>
<dt><code>(a b c)</code><dd><code>a</code>, <code>b</code>, and <code>c</code> are all required.  The procedure must
be passed exactly three arguments.

          <br><dt><code>(a b #!optional c)</code><dd><code>a</code> and <code>b</code> are required, <code>c</code> is optional.  The procedure
may be passed either two or three arguments.

          <br><dt><code>(#!optional a b c)</code><dd><code>a</code>, <code>b</code>, and <code>c</code> are all optional.  The procedure may be
passed any number of arguments between zero and three, inclusive.

          <br><dt><code>a</code><dt><code>(#!rest a)</code><dd>These two examples are equivalent.  <code>a</code> is a rest parameter.  The
procedure may be passed any number of arguments.  Note: this is the only
case in which &lsquo;<samp><span class="samp">.</span></samp>&rsquo; cannot be used in place of &lsquo;<samp><span class="samp">#!rest</span></samp>&rsquo;.

          <br><dt><code>(a b #!optional c d #!rest e)</code><dd><code>a</code> and <code>b</code> are required, <code>c</code> and <code>d</code> are optional,
and <code>e</code> is rest.  The procedure may be passed two or more
arguments. 
</dl>

        <p>Some examples of <code>lambda</code> expressions:

     <pre class="example">          (lambda (x) (+ x x))            &rArr;  #[compound-procedure 53]
          
          ((lambda (x) (+ x x)) 4)                &rArr;  8
          
          (define reverse-subtract
            (lambda (x y)
              (- y x)))
          (reverse-subtract 7 10)                 &rArr;  3
          
          (define foo
            (let ((x 4))
              (lambda (y) (+ x y))))
          (foo 6)                                 &rArr;  10
</pre>
        </blockquote></div>

<div class="defun">
&mdash; special form: <b>named-lambda</b><var> formals expression expression <small class="dots">...</small><a name="index-named_002dlambda-206"></a></var><br>
<blockquote><p><a name="index-named-lambda-_0028defn_0029-207"></a>The <code>named-lambda</code> special form is similar to <code>lambda</code>, except
that the first &ldquo;required parameter&rdquo; in <var>formals</var> is not a
parameter but the <dfn>name</dfn> of the resulting procedure; thus
<var>formals</var> must have at least one required parameter.  This name has
no semantic meaning, but is included in the external representation of
the procedure, making it useful for debugging.  In MIT/GNU Scheme,
<code>lambda</code> is implemented as <code>named-lambda</code>, with a special name
that means &ldquo;unnamed&rdquo;.

     <pre class="example">          (named-lambda (f x) (+ x x))    &rArr;  #[compound-procedure 53 f]
          ((named-lambda (f x) (+ x x)) 4)        &rArr;  8
</pre>
        </blockquote></div>

   </body></html>

