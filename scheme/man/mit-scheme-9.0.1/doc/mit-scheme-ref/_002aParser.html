<html lang="en">
<head>
<title>*Parser - MIT/GNU Scheme 9.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Parser-Language.html#Parser-Language" title="Parser Language">
<link rel="prev" href="_002aMatcher.html#g_t_002aMatcher" title="*Matcher">
<link rel="next" href="Parser_002dlanguage-Macros.html#Parser_002dlanguage-Macros" title="Parser-language Macros">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents MIT/GNU Scheme 9.0.1.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="*Parser"></a>
<a name="g_t_002aParser"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Parser_002dlanguage-Macros.html#Parser_002dlanguage-Macros">Parser-language Macros</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="_002aMatcher.html#g_t_002aMatcher">*Matcher</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Parser-Language.html#Parser-Language">Parser Language</a>
<hr>
</div>

<h4 class="subsection">14.11.2 *Parser</h4>

<p><a name="index-Parser-language-2289"></a><a name="index-Parser-procedure-2290"></a>The <dfn>parser language</dfn> is a declarative language for specifying a
<dfn>parser procedure</dfn>.  A parser procedure is a procedure that
accepts a single parser-buffer argument and parses some of the input
from the buffer.  If the parse is successful, the procedure returns a
vector of objects that are the result of the parse, and the internal
pointer of the parser buffer is advanced past the input that was
parsed.  If the parse fails, the procedure returns <code>#f</code> and the
internal pointer is unchanged.  This interface is much like that of a
matcher procedure, except that on success the parser procedure returns
a vector of values rather than <code>#t</code>.

   <p>The <code>*parser</code> special form is the interface between the parser
language and Scheme.

<div class="defun">
&mdash; special form: <b>*parser</b><var> pexp<a name="index-g_t_002aparser-2291"></a></var><br>
<blockquote><p>The operand <var>pexp</var> is an expression in the parser language.  The
<code>*parser</code> expression expands into Scheme code that implements a
parser procedure. 
</p></blockquote></div>

   <p>There are several primitive expressions in the parser language.  The
first two provide a bridge to the matcher language (see <a href="_002aMatcher.html#g_t_002aMatcher">*Matcher</a>):

<div class="defun">
&mdash; parser expression: <b>match</b><var> mexp<a name="index-match-2292"></a></var><br>
<blockquote><p>The <code>match</code> expression performs a match on the parser buffer. 
The match to be performed is specified by <var>mexp</var>, which is an
expression in the matcher language.  If the match is successful, the
result of the <code>match</code> expression is a vector of one element: a
string containing that text. 
</p></blockquote></div>

<div class="defun">
&mdash; parser expression: <b>noise</b><var> mexp<a name="index-noise-2293"></a></var><br>
<blockquote><p>The <code>noise</code> expression performs a match on the parser buffer. 
The match to be performed is specified by <var>mexp</var>, which is an
expression in the matcher language.  If the match is successful, the
result of the <code>noise</code> expression is a vector of zero elements. 
(In other words, the text is matched and then thrown away.)

        <p>The <var>mexp</var> operand is often a known character or string, so in the
case that <var>mexp</var> is a character or string literal, the
<code>noise</code> expression can be abbreviated as the literal.  In other
words, &lsquo;<samp><span class="samp">(noise "foo")</span></samp>&rsquo; can be abbreviated just &lsquo;<samp><span class="samp">"foo"</span></samp>&rsquo;. 
</p></blockquote></div>

<div class="defun">
&mdash; parser expression: <b>values</b><var> expression <small class="dots">...</small><a name="index-values-2294"></a></var><br>
<blockquote><p>Sometimes it is useful to be able to insert arbitrary values into the
parser result.  The <code>values</code> expression supports this.  The
<var>expression</var> arguments are arbitrary Scheme expressions that are
evaluated at run time and returned in a vector.  The <code>values</code>
expression always succeeds and never modifies the internal pointer of
the parser buffer. 
</p></blockquote></div>

<div class="defun">
&mdash; parser expression: <b>discard-matched</b><var><a name="index-discard_002dmatched-2295"></a></var><br>
<blockquote><p>The <code>discard-matched</code> expression always succeeds, returning a
vector of zero elements.  In all other respects it is identical to the
<code>discard-matched</code> expression in the matcher language. 
</p></blockquote></div>

   <p>Next there are several combinator expressions.  Parameters named
<var>pexp</var> are arbitrary expressions in the parser language.  The
first few combinators are direct equivalents of those in the matcher
language.

<div class="defun">
&mdash; parser expression: <b>seq</b><var> pexp <small class="dots">...</small><a name="index-seq-2296"></a></var><br>
<blockquote><p>The <code>seq</code> expression parses each of the <var>pexp</var> operands in
order.  If all of the <var>pexp</var> operands successfully match, the
result is the concatenation of their values (by <code>vector-append</code>). 
</p></blockquote></div>

<div class="defun">
&mdash; parser expression: <b>alt</b><var> pexp <small class="dots">...</small><a name="index-alt-2297"></a></var><br>
<blockquote><p>The <code>alt</code> expression attempts to parse each <var>pexp</var> operand in
order from left to right.  The first one that successfully parses
produces the result for the entire <code>alt</code> expression.

        <p>Like the <code>alt</code> expression in the matcher language, this
expression participates in backtracking. 
</p></blockquote></div>

<div class="defun">
&mdash; parser expression: <b>*</b><var> pexp<a name="index-g_t_002a-2298"></a></var><br>
<blockquote><p>The <code>*</code> expression parses zero or more occurrences of <var>pexp</var>. 
The results of the parsed occurrences are concatenated together (by
<code>vector-append</code>) to produce the expression's result.

        <p>Like the <code>*</code> expression in the matcher language, this expression
participates in backtracking. 
</p></blockquote></div>

<div class="defun">
&mdash; parser expression: <b>+</b><var> pexp<a name="index-g_t_002b-2299"></a></var><br>
<blockquote><p>The <code>*</code> expression parses one or more occurrences of <var>pexp</var>. 
It is equivalent to

     <pre class="example">          (seq <var>pexp</var> (* <var>pexp</var>))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; parser expression: <b>?</b><var> pexp<a name="index-g_t_003f-2300"></a></var><br>
<blockquote><p>The <code>*</code> expression parses zero or one occurrences of <var>pexp</var>. 
It is equivalent to

     <pre class="example">          (alt <var>pexp</var> (seq))
</pre>
        </blockquote></div>

   <p>The next three expressions do not have equivalents in the matcher
language.  Each accepts a single <var>pexp</var> argument, which is parsed
in the usual way.  These expressions perform transformations on the
returned values of a successful match.

<div class="defun">
&mdash; parser expression: <b>transform</b><var> expression pexp<a name="index-transform-2301"></a></var><br>
<blockquote><p>The <code>transform</code> expression performs an arbitrary transformation
of the values returned by parsing <var>pexp</var>.  <var>Expression</var> is a
Scheme expression that must evaluate to a procedure at run time.  If
<var>pexp</var> is successfully parsed, the procedure is called with the
vector of values as its argument, and must return a vector or
<code>#f</code>.  If it returns a vector, the parse is successful, and those
are the resulting values.  If it returns <code>#f</code>, the parse fails
and the internal pointer of the parser buffer is returned to what it
was before <var>pexp</var> was parsed.

        <p>For example:

     <pre class="example">          (transform (lambda (v) (if (= 0 (vector-length v)) #f v)) ...)
</pre>
        </blockquote></div>

<div class="defun">
&mdash; parser expression: <b>encapsulate</b><var> expression pexp<a name="index-encapsulate-2302"></a></var><br>
<blockquote><p>The <code>encapsulate</code> expression transforms the values returned by
parsing <var>pexp</var> into a single value.  <var>Expression</var> is a Scheme
expression that must evaluate to a procedure at run time.  If
<var>pexp</var> is successfully parsed, the procedure is called with the
vector of values as its argument, and may return any Scheme object. 
The result of the <code>encapsulate</code> expression is a vector of length
one containing that object.  (And consequently <code>encapsulate</code>
doesn't change the success or failure of <var>pexp</var>, only its value.)

        <p>For example:

     <pre class="example">          (encapsulate vector-&gt;list ...)
</pre>
        </blockquote></div>

<div class="defun">
&mdash; parser expression: <b>map</b><var> expression pexp<a name="index-map-2303"></a></var><br>
<blockquote><p>The <code>map</code> expression performs a per-element transform on the
values returned by parsing <var>pexp</var>.  <var>Expression</var> is a Scheme
expression that must evaluate to a procedure at run time.  If
<var>pexp</var> is successfully parsed, the procedure is mapped (by
<code>vector-map</code>) over the values returned from the parse.  The
mapped values are returned as the result of the <code>map</code> expression. 
(And consequently <code>map</code> doesn't change the success or failure of
<var>pexp</var>, nor the number of values returned.)

        <p>For example:

     <pre class="example">          (map string-&gt;symbol ...)
</pre>
        </blockquote></div>

   <p>Finally, as in the matcher language, we have <code>sexp</code> and
<code>with-pointer</code> to support embedding Scheme code in the parser.

<div class="defun">
&mdash; parser expression: <b>sexp</b><var> expression<a name="index-sexp-2304"></a></var><br>
<blockquote><p>The <code>sexp</code> expression allows arbitrary Scheme code to be embedded
inside a parser.  The <var>expression</var> operand must evaluate to a
parser procedure at run time; the procedure is called to parse the
parser buffer.  This is the parser-language equivalent of the
<code>sexp</code> expression in the matcher language.

        <p>The case in which <var>expression</var> is a symbol is so common that it
has an abbreviation: &lsquo;<samp><span class="samp">(sexp </span><var>symbol</var><span class="samp">)</span></samp>&rsquo; may be abbreviated as
just <var>symbol</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; parser expression: <b>with-pointer</b><var> identifier pexp<a name="index-with_002dpointer-2305"></a></var><br>
<blockquote><p>The <code>with-pointer</code> expression fetches the parser buffer's
internal pointer (using <code>get-parser-buffer-pointer</code>), binds it to
<var>identifier</var>, and then parses the pattern specified by <var>pexp</var>. 
<var>Identifier</var> must be a symbol.  This is the parser-language
equivalent of the <code>with-pointer</code> expression in the matcher
language. 
</p></blockquote></div>

   </body></html>

