<html lang="en">
<head>
<title>Filtering Lists - MIT/GNU Scheme 9.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Lists.html#Lists" title="Lists">
<link rel="prev" href="Cutting-and-Pasting-Lists.html#Cutting-and-Pasting-Lists" title="Cutting and Pasting Lists">
<link rel="next" href="Searching-Lists.html#Searching-Lists" title="Searching Lists">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents MIT/GNU Scheme 9.0.1.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Filtering-Lists"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Searching-Lists.html#Searching-Lists">Searching Lists</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Cutting-and-Pasting-Lists.html#Cutting-and-Pasting-Lists">Cutting and Pasting Lists</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Lists.html#Lists">Lists</a>
<hr>
</div>

<h3 class="section">7.5 Filtering Lists</h3>

<p><a name="index-filtering_002c-of-list-1231"></a><a name="index-deletion_002c-of-list-element-1232"></a>

<div class="defun">
&mdash; procedure: <b>filter</b><var> predicate list<a name="index-filter-1233"></a></var><br>
<blockquote><p>(<acronym>SRFI</acronym> 1) Returns a newly allocated copy of <var>list</var>
containing only the elements satisfying <var>predicate</var>. 
<var>Predicate</var> must be a procedure of one argument.

     <pre class="example">          (filter odd? '(1 2 3 4 5)) &rArr; (1 3 5)
</pre>
        <p><a name="index-keep_002dmatching_002ditems-1234"></a><a name="index-list_002dtransform_002dpositive-1235"></a>The non-standard procedure <code>keep-matching-items</code> (and its alias
<code>list-transform-positive</code>) are the same except that its arguments
are reversed. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>remove</b><var> predicate list<a name="index-remove-1236"></a></var><br>
<blockquote><p>(<acronym>SRFI</acronym> 1) Like <code>filter</code>, except that the returned list
contains only those elements <em>not</em> satisfying <var>predicate</var>.

     <pre class="example">          (remove odd? '(1 2 3 4 5)) &rArr; (2 4)
</pre>
        <p><a name="index-delete_002dmatching_002ditems-1237"></a><a name="index-list_002dtransform_002dnegative-1238"></a>The non-standard procedure <code>delete-matching-items</code> (and its alias
<code>list-transform-negative</code>) are the same except that its arguments
are reversed. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>partition</b><var> predicate list<a name="index-partition-1239"></a></var><br>
<blockquote><p>(<acronym>SRFI</acronym> 1) Partitions the elements of <var>list</var> with
<var>predicate</var>, and returns two values: the list of in-elements and
the list of out-elements.  The <var>list</var> is not disordered&mdash;elements
occur in the result lists in the same order as they occur in the
argument <var>list</var>. The dynamic order in which the various
applications of <code>predicate</code> are made is not specified.  One of
the returned lists may share a common tail with the argument
<var>list</var>.

     <pre class="example">          (partition symbol? '(one 2 3 four five 6)) =&gt;
              (one four five)
              (2 3 6)
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>filter!</b><var> predicate list<a name="index-filter_0021-1240"></a></var><br>
&mdash; procedure: <b>remove!</b><var> predicate list<a name="index-remove_0021-1241"></a></var><br>
&mdash; procedure: <b>partition!</b><var> predicate list<a name="index-partition_0021-1242"></a></var><br>
<blockquote><p>(<acronym>SRFI</acronym> 1) Linear-update variants of <code>filter</code>,
<code>remove</code> and <code>partition</code>. These procedures are allowed, but
not required, to alter the cons cells in the argument <code>list</code> to
construct the result lists.

        <p><a name="index-keep_002dmatching_002ditems_0021-1243"></a><a name="index-delete_002dmatching_002ditems_0021-1244"></a>The non-standard procedures <code>keep-matching-items!</code> and
<code>delete-matching-items!</code> bear a similar relationship to
<code>keep-matching-items</code> and <code>delete-matching-items</code>,
respectively. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>delq</b><var> element list<a name="index-delq-1245"></a></var><br>
&mdash; procedure: <b>delv</b><var> element list<a name="index-delv-1246"></a></var><br>
&mdash; procedure: <b>delete</b><var> element list<a name="index-delete-1247"></a></var><br>
<blockquote><p><a name="index-eq_003f-1248"></a><a name="index-eqv_003f-1249"></a><a name="index-equal_003f-1250"></a>Returns a newly allocated copy of <var>list</var> with all entries equal to
<var>element</var> removed.  <code>delq</code> uses <code>eq?</code> to compare
<var>element</var> with the entries in <var>list</var>, <code>delv</code> uses
<code>eqv?</code>, and <code>delete</code> uses <code>equal?</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>delq!</b><var> element list<a name="index-delq_0021-1251"></a></var><br>
&mdash; procedure: <b>delv!</b><var> element list<a name="index-delv_0021-1252"></a></var><br>
&mdash; procedure: <b>delete!</b><var> element list<a name="index-delete_0021-1253"></a></var><br>
<blockquote><p><a name="index-eq_003f-1254"></a><a name="index-eqv_003f-1255"></a><a name="index-equal_003f-1256"></a>Returns a list consisting of the top-level elements of <var>list</var> with
all entries equal to <var>element</var> removed.  These procedures are like
<code>delq</code>, <code>delv</code>, and <code>delete</code> except that they
destructively modify <var>list</var>.  <code>delq!</code> uses <code>eq?</code> to
compare element with the entries in <var>list</var>, <code>delv!</code> uses
<code>eqv?</code>, and <code>delete!</code> uses <code>equal?</code>.  Because the result
may not be <code>eq?</code> to <var>list</var>, it is desirable to do something
like <code>(set! x (delete! x))</code>.

     <pre class="example">          (define x '(a b c b))
          (delete 'b x)                           &rArr; (a c)
          x                                       &rArr; (a b c b)
          
          (define x '(a b c b))
          (delete! 'b x)                          &rArr; (a c)
          x                                       &rArr; (a c)
          <span class="roman">;; Returns correct result:</span>
          (delete! 'a x)                          &rArr; (c)
          
          <span class="roman">;; Didn't modify what x points to:</span>
          x                                       &rArr; (a c)
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>delete-member-procedure</b><var> deletor predicate<a name="index-delete_002dmember_002dprocedure-1257"></a></var><br>
<blockquote><p><a name="index-list_002ddeletor-1258"></a><a name="index-list_002ddeletor_0021-1259"></a><a name="index-delv-1260"></a><a name="index-delete_0021-1261"></a>Returns a deletion procedure similar to <code>delv</code> or <code>delete!</code>. 
<var>Deletor</var> should be one of the procedures <code>list-deletor</code> or
<code>list-deletor!</code>.  <var>Predicate</var> must be an equivalence predicate. 
The returned procedure accepts exactly two arguments: first, an object
to be deleted, and second, a list of objects from which it is to be
deleted.  If <var>deletor</var> is <code>list-deletor</code>, the procedure
returns a newly allocated copy of the given list in which all entries
equal to the given object have been removed.  If <var>deletor</var> is
<code>list-deletor!</code>, the procedure returns a list consisting of the
top-level elements of the given list with all entries equal to the given
object removed; the given list is destructively modified to produce the
result.  In either case <var>predicate</var> is used to compare the given
object to the elements of the given list.

        <p>Here are some examples that demonstrate how
<code>delete-member-procedure</code> could have been used to implement
<code>delv</code> and <code>delete!</code>:

     <pre class="example">          (define delv
            (delete-member-procedure list-deletor eqv?))
          (define delete!
            (delete-member-procedure list-deletor! equal?))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>list-deletor</b><var> predicate<a name="index-list_002ddeletor-1262"></a></var><br>
&mdash; procedure: <b>list-deletor!</b><var> predicate<a name="index-list_002ddeletor_0021-1263"></a></var><br>
<blockquote><p>These procedures each return a procedure that deletes elements from
lists.  <var>Predicate</var> must be a procedure of one argument.  The
returned procedure accepts exactly one argument, which must be a proper
list, and applies <var>predicate</var> to each of the elements of the
argument, deleting those for which it is true.

        <p>The procedure returned by <code>list-deletor</code> deletes elements
non-destructively, by returning a newly allocated copy of the argument
with the appropriate elements removed.  The procedure returned by
<code>list-deletor!</code> performs a destructive deletion. 
</p></blockquote></div>

   </body></html>

