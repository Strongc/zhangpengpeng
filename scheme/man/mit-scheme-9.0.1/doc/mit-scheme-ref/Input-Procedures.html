<html lang="en">
<head>
<title>Input Procedures - MIT/GNU Scheme 9.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Input_002fOutput.html#Input_002fOutput" title="Input/Output">
<link rel="prev" href="String-Ports.html#String-Ports" title="String Ports">
<link rel="next" href="Output-Procedures.html#Output-Procedures" title="Output Procedures">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents MIT/GNU Scheme 9.0.1.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Input-Procedures"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Output-Procedures.html#Output-Procedures">Output Procedures</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="String-Ports.html#String-Ports">String Ports</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Input_002fOutput.html#Input_002fOutput">Input/Output</a>
<hr>
</div>

<h3 class="section">14.4 Input Procedures</h3>

<p><a name="index-input-operations-2053"></a>
This section describes the procedures that read input.  Input procedures
can read either from the current input port or from a given port. 
Remember that to read from a file, you must first open a port to the
file.

   <p><a name="index-interactive-input-ports-_0028defn_0029-2054"></a>Input ports can be divided into two types, called <dfn>interactive</dfn> and
<dfn>non-interactive</dfn>.  Interactive input ports are ports that read
input from a source that is time-dependent; for example, a port that
reads input from a terminal or from another program.  Non-interactive
input ports read input from a time-independent source, such as an
ordinary file or a character string.

   <p>All optional arguments called <var>input-port</var>, if not supplied, default
to the current input port.

<div class="defun">
&mdash; procedure: <b>read-char</b> [<var>input-port</var>]<var><a name="index-read_002dchar-2055"></a></var><br>
<blockquote><p><a name="index-character_002c-input-from-port-2056"></a>Returns the next character available from <var>input-port</var>, updating
<var>input-port</var> to point to the following character.  If no more
characters are available, an end-of-file object is returned.

        <p>In MIT/GNU Scheme, if <var>input-port</var> is an interactive input port and no
characters are immediately available, <code>read-char</code> will hang waiting
for input, even if the port is in non-blocking mode. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>peek-char</b> [<var>input-port</var>]<var><a name="index-peek_002dchar-2057"></a></var><br>
<blockquote><p>Returns the next character available from <var>input-port</var>,
<em>without</em> updating <var>input-port</var> to point to the following
character.  If no more characters are available, an end-of-file object
is returned.<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>

        <p>In MIT/GNU Scheme, if <var>input-port</var> is an interactive input port and no
characters are immediately available, <code>peek-char</code> will hang waiting
for input, even if the port is in non-blocking mode. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>char-ready?</b> [<var>input-port</var>]<var><a name="index-char_002dready_003f-2058"></a></var><br>
<blockquote><p><a name="index-read_002dchar-2059"></a>Returns <code>#t</code> if a character is ready on <var>input-port</var> and
returns <code>#f</code> otherwise.  If <code>char-ready?</code> returns <code>#t</code>
then the next <code>read-char</code> operation on <var>input-port</var> is
guaranteed not to hang.  If <var>input-port</var> is a file port at end of
file then <code>char-ready?</code> returns
<code>#t</code>.<a rel="footnote" href="#fn-2" name="fnd-2"><sup>2</sup></a>
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>read</b> [<var>input-port </var>[<var>environment</var>]]<var><a name="index-read-2060"></a></var><br>
<blockquote><p><a name="index-expression_002c-input-from-port-2061"></a><a name="index-external-representation_002c-parsing-2062"></a><a name="index-parsing_002c-of-external-representation-2063"></a>Converts external representations of Scheme objects into the objects
themselves.  <code>read</code> returns the next object parsable from
<var>input-port</var>, updating <var>input-port</var> to point to the first
character past the end of the written representation of the object.  If
an end of file is encountered in the input before any characters are
found that can begin an object, <code>read</code> returns an end-of-file
object.  The <var>input-port</var> remains open, and further attempts to read
will also return an end-of-file object.  If an end of file is
encountered after the beginning of an object's written representation,
but the written representation is incomplete and therefore not parsable,
an error is signalled.

        <p><var>Environment</var> is used to look up the values of control variables
such as &lsquo;<samp><span class="samp">*parser-radix*</span></samp>&rsquo;.  If not supplied, it defaults to the
<acronym>REP</acronym> environment. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>eof-object?</b><var> object<a name="index-eof_002dobject_003f-2064"></a></var><br>
<blockquote><p><a name="index-type-predicate_002c-for-EOF-object-2065"></a><a name="index-EOF-object_002c-predicate-for-2066"></a><a name="index-end-of-file-object-_0028see-EOF-object_0029-2067"></a><a name="index-file_002c-end_002dof_002dfile-marker-_0028see-EOF-object_0029-2068"></a>Returns <code>#t</code> if <var>object</var> is an end-of-file object; otherwise
returns <code>#f</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>read-char-no-hang</b> [<var>input-port</var>]<var><a name="index-read_002dchar_002dno_002dhang-2069"></a></var><br>
<blockquote><p>If <var>input-port</var> can deliver a character without blocking, this
procedure acts exactly like <code>read-char</code>, immediately returning that
character.  Otherwise, <code>#f</code> is returned, unless <var>input-port</var> is
a file port at end of file, in which case an end-of-file object is
returned.  In no case will this procedure block waiting for input. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>read-string</b><var> char-set </var>[<var>input-port</var>]<var><a name="index-read_002dstring-2070"></a></var><br>
<blockquote><p><a name="index-string_002c-input-from-port-2071"></a>Reads characters from <var>input-port</var> until it finds a terminating
character that is a member of <var>char-set</var> (see <a href="Character-Sets.html#Character-Sets">Character Sets</a>) or
encounters end of file.  The port is updated to point to the terminating
character, or to end of file if no terminating character was found. 
<code>read-string</code> returns the characters, up to but excluding the
terminating character, as a newly allocated string.

        <p>This procedure ignores the blocking mode of the port, blocking
unconditionally until it sees either a delimiter or end of file.  If end
of file is encountered before any characters are read, an end-of-file
object is returned.

        <p><a name="index-read_002dchar-2072"></a>On many input ports, this operation is significantly faster than the
following equivalent code using <code>peek-char</code> and <code>read-char</code>:

     <pre class="example">          (define (read-string char-set input-port)
            (let ((char (peek-char input-port)))
              (if (eof-object? char)
                  char
                  (list-&gt;string
                   (let loop ((char char))
                     (if (or (eof-object? char)
                             (char-set-member? char-set char))
                         '()
                         (begin
                           (read-char input-port)
                           (cons char
                                 (loop (peek-char input-port))))))))))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>read-line</b> [<var>input-port</var>]<var><a name="index-read_002dline-2073"></a></var><br>
<blockquote><p><code>read-line</code> reads a single line of text from <var>input-port</var>, and
returns that line as a newly allocated string.  The <code>#\newline</code>
terminating the line, if any, is discarded and does not appear in the
returned string.

        <p>This procedure ignores the blocking mode of the port, blocking
unconditionally until it has read an entire line.  If end of file is
encountered before any characters are read, an end-of-file object is
returned. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>read-string!</b><var> string </var>[<var>input-port</var>]<var><a name="index-read_002dstring_0021-2074"></a></var><br>
&mdash; procedure: <b>read-substring!</b><var> string start end </var>[<var>input-port</var>]<var><a name="index-read_002dsubstring_0021-2075"></a></var><br>
<blockquote><p><code>read-string!</code> and <code>read-substring!</code> fill the specified region
of <var>string</var> with characters read from <var>input-port</var> until the
region is full or else there are no more characters available from the
port.  For <code>read-string!</code>, the region is all of <var>string</var>, and
for <code>read-substring!</code>, the region is that part of <var>string</var>
specified by <var>start</var> and <var>end</var>.

        <p>The returned value is the number of characters filled into the region. 
However, there are several interesting cases to consider:

          <ul>
<li>If <code>read-string!</code> (<code>read-substring!</code>) is called when
<var>input-port</var> is at &ldquo;end-of-file&rdquo;, then the returned value is
<code>0</code>.  Note that &ldquo;end-of-file&rdquo; can mean a file port that is at the
file's end, a string port that is at the string's end, or any other port
that will never produce more characters.

          <li>If <var>input-port</var> is an interactive port (e.g. a terminal), and one
or more characters are immediately available, the region is filled using
the available characters.  The procedure then returns immediately,
without waiting for further characters, even if the number of available
characters is less than the size of the region.  The returned value is
the number of characters actually filled in.

          <li>If <var>input-port</var> is an interactive port and no characters are
immediately available, the result of the operation depends on the
blocking mode of the port.  If the port is in non-blocking mode,
<code>read-string!</code> (<code>read-substring!</code>) immediately returns the
value <code>#f</code>.  Otherwise, the operation blocks until a character is
available.  As soon as at least one character is available, the region
is filled using the available characters.  The procedure then returns
immediately, without waiting for further characters, even if the number
of available characters is less than the size of the region.  The
returned value is the number of characters actually filled in. 
</ul>

        <p>The importance of <code>read-string!</code> and <code>read-substring!</code> are
that they are both flexible and extremely fast, especially for large
amounts of data. 
</p></blockquote></div>

   <p>The following variables may be bound or assigned to change the behavior
of the <code>read</code> procedure.  They are looked up in the environment
that is passed to <code>read</code>, and so may have different values in
different environments.  It is recommended that the global bindings of
these variables be left unchanged; make local changes by shadowing the
global bindings in nested environments.

<div class="defun">
&mdash; variable: <b>*parser-radix*</b><var><a name="index-g_t_002aparser_002dradix_002a-2076"></a></var><br>
<blockquote><p>This variable defines the radix used by the reader when it parses
numbers.  This is similar to passing a radix argument to
<code>string-&gt;number</code>.  The value of this variable must be one of
<code>2</code>, <code>8</code>, <code>10</code>, or <code>16</code>; any other value is ignored,
and the reader uses radix <code>10</code>.

        <p>Note that much of the number syntax is invalid for radixes other than
<code>10</code>.  The reader detects cases where such invalid syntax is used
and signals an error.  However, problems can still occur when
<code>*parser-radix*</code> is set to <code>16</code>, because syntax that normally
denotes symbols can now denote numbers (e.g. <code>abc</code>).  Because of
this, it is usually undesirable to set this variable to anything other
than the default.

        <p>The default value of this variable is <code>10</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; variable: <b>*parser-canonicalize-symbols?*</b><var><a name="index-g_t_002aparser_002dcanonicalize_002dsymbols_003f_002a-2077"></a></var><br>
<blockquote><p>This variable controls how the parser handles case-sensitivity of
symbols.  If it is bound to its default value of <code>#t</code>, symbols read
by the parser are converted to lower case before being interned. 
Otherwise, symbols are interned without case conversion.

        <p>In general, it is a bad idea to use this feature, as it doesn't really
make Scheme case-sensitive, and therefore can break features of the
Scheme runtime that depend on case-insensitive symbols. 
</p></blockquote></div>

   <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> The value returned by a call to <code>peek-char</code>
is the same as the value that would have been returned by a call to
<code>read-char</code> on the same port.  The only difference is that the very
next call to <code>read-char</code> or <code>peek-char</code> on that
<var>input-port</var> will return the value returned by the preceding call to
<code>peek-char</code>.  In particular, a call to <code>peek-char</code> on an
interactive port will hang waiting for input whenever a call to
<code>read-char</code> would have hung.</p>

   <p class="footnote"><small>[<a name="fn-2" href="#fnd-2">2</a>]</small> <code>char-ready?</code> exists to make it possible for a
program to accept characters from interactive ports without getting
stuck waiting for input.  Any input editors associated with such ports
must make sure that characters whose existence has been asserted by
<code>char-ready?</code> cannot be rubbed out.  If <code>char-ready?</code> were to
return <code>#f</code> at end of file, a port at end of file would be
indistinguishable from an interactive port that has no ready
characters.</p>

   <hr></div>

   </body></html>

