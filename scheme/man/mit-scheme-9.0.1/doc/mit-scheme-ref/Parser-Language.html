<html lang="en">
<head>
<title>Parser Language - MIT/GNU Scheme 9.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Input_002fOutput.html#Input_002fOutput" title="Input/Output">
<link rel="prev" href="Parser-Buffers.html#Parser-Buffers" title="Parser Buffers">
<link rel="next" href="XML-Support.html#XML-Support" title="XML Support">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents MIT/GNU Scheme 9.0.1.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Parser-Language"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="XML-Support.html#XML-Support">XML Support</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Parser-Buffers.html#Parser-Buffers">Parser Buffers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Input_002fOutput.html#Input_002fOutput">Input/Output</a>
<hr>
</div>

<h3 class="section">14.11 Parser Language</h3>

<p><a name="index-Parser-language-2264"></a>Although it is possible to write parsers using the parser-buffer
abstraction (see <a href="Parser-Buffers.html#Parser-Buffers">Parser Buffers</a>), it is tedious.  The problem is
that the abstraction isn't closely matched to the way that people
think about syntactic structures.  In this section, we introduce a
higher-level mechanism that greatly simplifies the implementation of a
parser.

   <p>The <dfn>parser language</dfn> described here allows the programmer to
write <acronym>BNF</acronym>-like specifications that are translated into
efficient Scheme code at compile time.  The language is declarative,
but it can be freely mixed with Scheme code; this allows the parsing
of grammars that aren't conveniently described in the language.

   <p><a name="index-Backtracking_002c-in-parser-language-2265"></a>The language also provides backtracking.  For example, this expression
matches any sequence of alphanumeric characters followed by a single
alphabetic character:

<pre class="example">     (*matcher
      (seq (* (char-set char-set:alphanumeric))
           (char-set char-set:alphabetic)))
</pre>
   <p class="noindent">The way that this works is that the matcher matches alphanumeric
characters in the input stream until it finds a non-alphanumeric
character.  It then tries to match an alphabetic character, which of
course fails.  At this point, if it matched at least one alphanumeric
character, it <em>backtracks</em>: the last matched alphanumeric is
&ldquo;unmatched&rdquo;, and it again attempts to match an alphabetic
character.  The backtracking can be arbitrarily deep; the matcher will
continue to back up until it finds a way to match the remainder of the
expression.

   <p>So far, this sounds a lot like regular-expression matching
(see <a href="Regular-Expressions.html#Regular-Expressions">Regular Expressions</a>).  However, there are some important
differences.

     <ul>
<li>The parser language uses a Scheme-like syntax that is easier to read
and write than regular-expression notation.

     <li>The language provides macros so that common syntactic constructs can
be abstracted.

     <li>The language mixes easily with Scheme code, allowing the full power of
Scheme to be applied to program around limitations in the parser
language.

     <li>The language provides expressive facilities for converting syntax into
parsed structure.  It also makes it easy to convert parsed strings
into meaningful objects (e.g. numbers).

     <li>The language is compiled into machine language; regular expressions
are usually interpreted. 
</ul>

   <p>Here is an example that shows off several of the features of the
parser language.  The example is a parser for <acronym>XML</acronym> start
tags:

   <p><a name="with_002dpointer-example"></a>
<pre class="example">     (*parser
      (with-pointer p
        (seq "&lt;"
             parse-name
             parse-attribute-list
             (alt (match "&gt;")
                  (match "/&gt;")
                  (sexp
                   (lambda (b)
                     (error
                      (string-append
                       "Unterminated start tag at "
                       (parser-buffer-position-string p)))))))))
</pre>
   <p class="noindent">This shows that the basic description of a start tag is very similar
to its <acronym>BNF</acronym>.  Non-terminal symbols <code>parse-name</code> and
<code>parse-attribute-list</code> do most of the work, and the noise strings
<code>"&lt;"</code> and <code>"&gt;"</code> are the syntactic markers delimiting the
form.  There are two alternate endings for start tags, and if the
parser doesn't find either of the endings, the Scheme code (wrapped in
<code>sexp</code>) is run to signal an error.  The error procedure
<code>perror</code> takes a pointer <code>p</code>, which it uses to indicate the
position in the input stream at which the error occurred.  In this
case, that is the beginning of the start tag, i.e. the position of
the leading <code>"&lt;"</code> marker.

   <p>This example still looks pretty complicated, mostly due to the
error-signalling code.  In practice, this is abstracted into a macro,
after which the expression is quite succinct:

<pre class="example">     (*parser
      (bracket "start tag"
          (seq (noise (string "&lt;")) parse-name)
          (match (alt (string "&gt;") (string "/&gt;")))
        parse-attribute-list))
</pre>
   <p class="noindent">The <code>bracket</code> macro captures the pattern of a bracketed item, and
hides much of the detail.

   <p>The parser language actually consists of two languages: one for
defining matchers, and one for defining parsers.  The languages are
intentionally very similar, and are meant to be used together.  Each
sub-language is described below in its own section.

   <p><a name="index-run_002dtime_002dloadable-option-2266"></a><a name="index-option_002c-run_002dtime_002dloadable-2267"></a>The parser language is a run-time-loadable option; to use it, execute

<pre class="example">     (load-option '*parser)
</pre>
   <p><a name="index-load_002doption-2268"></a>
once before compiling any code that uses the language.

<ul class="menu">
<li><a accesskey="1" href="_002aMatcher.html#g_t_002aMatcher">*Matcher</a>
<li><a accesskey="2" href="_002aParser.html#g_t_002aParser">*Parser</a>
<li><a accesskey="3" href="Parser_002dlanguage-Macros.html#Parser_002dlanguage-Macros">Parser-language Macros</a>
</ul>

   </body></html>

