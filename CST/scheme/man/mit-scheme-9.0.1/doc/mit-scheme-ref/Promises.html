<html lang="en">
<head>
<title>Promises - MIT/GNU Scheme 9.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Miscellaneous-Datatypes.html#Miscellaneous-Datatypes" title="Miscellaneous Datatypes">
<link rel="prev" href="Records.html#Records" title="Records">
<link rel="next" href="Streams.html#Streams" title="Streams">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents MIT/GNU Scheme 9.0.1.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Promises"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Streams.html#Streams">Streams</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Records.html#Records">Records</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Miscellaneous-Datatypes.html#Miscellaneous-Datatypes">Miscellaneous Datatypes</a>
<hr>
</div>

<h3 class="section">10.5 Promises</h3>

<div class="defun">
&mdash; special form: <b>delay</b><var> expression<a name="index-delay-1523"></a></var><br>
<blockquote><p><a name="index-promise-_0028defn_0029-1524"></a><a name="index-promise_002c-construction-1525"></a><a name="index-construction_002c-of-promise-1526"></a><a name="index-lazy-evaluation-_0028defn_0029-1527"></a><a name="index-call-by-need-evaluation-_0028defn_0029-1528"></a><a name="index-evaluation_002c-lazy-_0028defn_0029-1529"></a><a name="index-evaluation_002c-call-by-need-_0028defn_0029-1530"></a>The <code>delay</code> construct is used together with the procedure
<code>force</code> to implement <dfn>lazy evaluation</dfn> or <dfn>call by need</dfn>. 
<code>(delay </code><var>expression</var><code>)</code> returns an object called a <dfn>promise</dfn>
which at some point in the future may be asked (by the <code>force</code>
procedure) to evaluate <var>expression</var> and deliver the resulting value. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>force</b><var> promise<a name="index-force-1531"></a></var><br>
<blockquote><p><a name="index-promise_002c-forcing-1532"></a><a name="index-forcing_002c-of-promise-1533"></a><a name="index-memoization_002c-of-promise-1534"></a>Forces the value of <em>promise</em>.  If no value has been computed for
the promise, then a value is computed and returned.  The value of the
promise is cached (or &ldquo;memoized&rdquo;) so that if it is forced a second
time, the previously computed value is returned without any
recomputation.

     <pre class="example">          (force (delay (+ 1 2)))                 &rArr;  3
          
          (let ((p (delay (+ 1 2))))
            (list (force p) (force p)))           &rArr;  (3 3)
          
          (define head car)
          
          (define tail
            (lambda (stream)
              (force (cdr stream))))
          
          (define a-stream
            (letrec ((next
                      (lambda (n)
                        (cons n (delay (next (+ n 1)))))))
              (next 0)))
          
          (head (tail (tail a-stream)))           &rArr;  2
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>promise?</b><var> object<a name="index-promise_003f-1535"></a></var><br>
<blockquote><p><a name="index-type-predicate_002c-for-promise-1536"></a>Returns <code>#t</code> if <var>object</var> is a promise; otherwise returns
<code>#f</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>promise-forced?</b><var> promise<a name="index-promise_002dforced_003f-1537"></a></var><br>
<blockquote><p>Returns <code>#t</code> if <var>promise</var> has been forced and its value cached;
otherwise returns <code>#f</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>promise-value</b><var> promise<a name="index-promise_002dvalue-1538"></a></var><br>
<blockquote><p>If <var>promise</var> has been forced and its value cached, this procedure
returns the cached value.  Otherwise, an error is signalled. 
</p></blockquote></div>

   <p><code>force</code> and <code>delay</code> are mainly intended for programs written
in functional style.  The following examples should not be considered to
illustrate good programming style, but they illustrate the property that
the value of a promise is computed at most once.

<pre class="example">     (define count 0)
     
     (define p
       (delay
        (begin
          (set! count (+ count 1))
          (* x 3))))
     
     (define x 5)
     
     count                                   &rArr;  0
     p                                       &rArr;  #[promise 54]
     (force p)                               &rArr;  15
     p                                       &rArr;  #[promise 54]
     count                                   &rArr;  1
     (force p)                               &rArr;  15
     count                                   &rArr;  1
</pre>
   <p>Here is a possible implementation of <code>delay</code> and <code>force</code>.  We
define the expression

<pre class="example">     (delay <var>expression</var>)
</pre>
   <p class="noindent">to have the same meaning as the procedure call

<pre class="example">     (make-promise (lambda () <var>expression</var>))
</pre>
   <p class="noindent">where <code>make-promise</code> is defined as follows:

<pre class="example">     (define make-promise
       (lambda (proc)
         (let ((already-run? #f)
               (result #f))
           (lambda ()
             (cond ((not already-run?)
                    (set! result (proc))
                    (set! already-run? #t)))
             result))))
</pre>
   <p>Promises are implemented here as procedures of no arguments, and
<code>force</code> simply calls its argument.

<pre class="example">     (define force
       (lambda (promise)
         (promise)))
</pre>
   <p>Various extensions to this semantics of <code>delay</code> and <code>force</code>
are supported in some implementations (none of these are currently
supported in MIT/GNU Scheme):

     <ul>
<li>Calling <code>force</code> on an object that is not a promise may simply
return the object.

     <li>It may be the case that there is no means by which a promise can be
operationally distinguished from its forced value.  That is, expressions
like the following may evaluate to either <code>#t</code> or <code>#f</code>,
depending on the implementation:

     <pre class="example">          (eqv? (delay 1) 1)              &rArr;  <span class="roman">unspecified</span>
          (pair? (delay (cons 1 2)))      &rArr;  <span class="roman">unspecified</span>
</pre>
     <li>Some implementations will implement &ldquo;implicit forcing&rdquo;, where the
value of a promise is forced by primitive procedures like <code>car</code> and
<code>+</code>:

     <pre class="example">          (+ (delay (* 3 7)) 13)          &rArr;  34
</pre>
     </ul>

   </body></html>

