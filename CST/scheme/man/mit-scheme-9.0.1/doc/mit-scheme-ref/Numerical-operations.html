<html lang="en">
<head>
<title>Numerical operations - MIT/GNU Scheme 9.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Numbers.html#Numbers" title="Numbers">
<link rel="prev" href="Syntax-of-numerical-constants.html#Syntax-of-numerical-constants" title="Syntax of numerical constants">
<link rel="next" href="Numerical-input-and-output.html#Numerical-input-and-output" title="Numerical input and output">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents MIT/GNU Scheme 9.0.1.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Numerical-operations"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Numerical-input-and-output.html#Numerical-input-and-output">Numerical input and output</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Syntax-of-numerical-constants.html#Syntax-of-numerical-constants">Syntax of numerical constants</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Numbers.html#Numbers">Numbers</a>
<hr>
</div>

<h3 class="section">4.5 Numerical operations</h3>

<p><a name="index-numerical-operations-474"></a>
See <a href="Entry-Format.html#Entry-Format">Entry Format</a>, for a summary of the naming conventions used to
specify restrictions on the types of arguments to numerical routines. 
The examples used in this section assume that any numerical constant
written using an exact notation is indeed represented as an exact
number.  Some examples also assume that certain numerical constants
written using an inexact notation can be represented without loss of
accuracy; the inexact constants were chosen so that this is likely to be
true in implementations that use flonums to represent inexact
numbers.

<div class="defun">
&mdash; procedure: <b>number?</b><var> object<a name="index-number_003f-475"></a></var><br>
&mdash; procedure: <b>complex?</b><var> object<a name="index-complex_003f-476"></a></var><br>
&mdash; procedure: <b>real?</b><var> object<a name="index-real_003f-477"></a></var><br>
&mdash; procedure: <b>rational?</b><var> object<a name="index-rational_003f-478"></a></var><br>
&mdash; procedure: <b>integer?</b><var> object<a name="index-integer_003f-479"></a></var><br>
<blockquote><p><a name="index-type-predicate_002c-for-number-480"></a>These numerical type predicates can be applied to any kind of argument,
including non-numbers.  They return <code>#t</code> if the object is of the
named type, and otherwise they return <code>#f</code>.  In general, if a type
predicate is true of a number then all higher type predicates are also
true of that number.  Consequently, if a type predicate is false of a
number, then all lower type predicates are also false of that
number.<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>

        <p><a name="index-zero_003f-481"></a><a name="index-g_t_003d-482"></a>If <var>z</var> is an inexact complex number, then <code>(real? </code><var>z</var><code>)</code> is
true if and only if <code>(zero? (imag-part </code><var>z</var><code>))</code> is true.  If
<var>x</var> is an inexact real number, then <code>(integer? </code><var>x</var><code>)</code> is
true if and only if <code>(= </code><var>x</var><code> (round </code><var>x</var><code>))</code>.

     <pre class="example">          (complex? 3+4i)         &rArr;  #t
          (complex? 3)            &rArr;  #t
          (real? 3)               &rArr;  #t
          (real? -2.5+0.0i)       &rArr;  #t
          (real? #e1e10)          &rArr;  #t
          (rational? 6/10)        &rArr;  #t
          (rational? 6/3)         &rArr;  #t
          (integer? 3+0i)         &rArr;  #t
          (integer? 3.0)          &rArr;  #t
          (integer? 8/4)          &rArr;  #t
</pre>
        <p>Note: The behavior of these type predicates on inexact numbers is
unreliable, since any inaccuracy may affect the result.

        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>exact?</b><var> z<a name="index-exact_003f-483"></a></var><br>
&mdash; procedure: <b>inexact?</b><var> z<a name="index-inexact_003f-484"></a></var><br>
<blockquote><p>These numerical predicates provide tests for the exactness of a
quantity.  For any Scheme number, precisely one of these predicates is
true. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>exact-integer?</b><var> object<a name="index-exact_002dinteger_003f-485"></a></var><br>
&mdash; procedure: <b>exact-nonnegative-integer?</b><var> object<a name="index-exact_002dnonnegative_002dinteger_003f-486"></a></var><br>
&mdash; procedure: <b>exact-rational?</b><var> object<a name="index-exact_002drational_003f-487"></a></var><br>
<blockquote><p>These procedures test for some very common types of numbers.  These
tests could be written in terms of simpler predicates, but are more
efficient. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>=</b><var> z1 z2 z3 <small class="dots">...</small><a name="index-g_t_003d-488"></a></var><br>
&mdash; procedure: <b>&lt;</b><var> x1 x2 x3 <small class="dots">...</small><a name="index-g_t_003c-489"></a></var><br>
&mdash; procedure: <b>&gt;</b><var> x1 x2 x3 <small class="dots">...</small><a name="index-g_t_003e-490"></a></var><br>
&mdash; procedure: <b>&lt;=</b><var> x1 x2 x3 <small class="dots">...</small><a name="index-g_t_003c_003d-491"></a></var><br>
&mdash; procedure: <b>&gt;=</b><var> x1 x2 x3 <small class="dots">...</small><a name="index-g_t_003e_003d-492"></a></var><br>
<blockquote><p><a name="index-ordering_002c-of-numbers-493"></a><a name="index-comparison_002c-of-numbers-494"></a><a name="index-equivalence-predicate_002c-for-numbers-495"></a>These procedures return <code>#t</code> if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing, monotonically
nondecreasing, or monotonically nonincreasing.

        <p>These predicates are transitive.  Note that the traditional
implementations of these predicates in Lisp-like languages are not
transitive.

        <p>Note: While it is not an error to compare inexact numbers using these
predicates, the results may be unreliable because a small inaccuracy may
affect the result; this is especially true of <code>=</code> and <code>zero?</code>. 
When in doubt, consult a numerical analyst. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>zero?</b><var> z<a name="index-zero_003f-496"></a></var><br>
&mdash; procedure: <b>positive?</b><var> x<a name="index-positive_003f-497"></a></var><br>
&mdash; procedure: <b>negative?</b><var> x<a name="index-negative_003f-498"></a></var><br>
&mdash; procedure: <b>odd?</b><var> x<a name="index-odd_003f-499"></a></var><br>
&mdash; procedure: <b>even?</b><var> x<a name="index-even_003f-500"></a></var><br>
<blockquote><p><a name="index-zero-501"></a><a name="index-positive-number-502"></a><a name="index-negative-number-503"></a><a name="index-odd-number-504"></a><a name="index-even-number-505"></a>These numerical predicates test a number for a particular property,
returning <code>#t</code> or <code>#f</code>.  See note above regarding inexact
numbers. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>max</b><var> x1 x2 <small class="dots">...</small><a name="index-max-506"></a></var><br>
&mdash; procedure: <b>min</b><var> x1 x2 <small class="dots">...</small><a name="index-min-507"></a></var><br>
<blockquote><p><a name="index-minimum_002c-of-numbers-508"></a><a name="index-maximum_002c-of-numbers-509"></a>These procedures return the maximum or minimum of their
arguments.

     <pre class="example">          (max 3 4)              &rArr;  4    <span class="roman">; exact</span>
          (max 3.9 4)            &rArr;  4.0  <span class="roman">; inexact</span>
</pre>
        <p>Note: If any argument is inexact, then the result will also be inexact
(unless the procedure can prove that the inaccuracy is not large enough
to affect the result, which is possible only in unusual
implementations).  If <code>min</code> or <code>max</code> is used to compare
numbers of mixed exactness, and the numerical value of the result cannot
be represented as an inexact number without loss of accuracy, then the
procedure may report a violation of an implementation
restriction.<a rel="footnote" href="#fn-2" name="fnd-2"><sup>2</sup></a>
<a name="index-condition_002dtype_003abad_002drange_002dargument-510"></a></p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>+</b><var> z1 <small class="dots">...</small><a name="index-g_t_002b-511"></a></var><br>
&mdash; procedure: <b>*</b><var> z1 <small class="dots">...</small><a name="index-g_t_002a-512"></a></var><br>
<blockquote><p><a name="index-addition_002c-of-numbers-513"></a><a name="index-sum_002c-of-numbers-514"></a><a name="index-identity_002c-additive-515"></a><a name="index-multiplication_002c-of-numbers-516"></a><a name="index-product_002c-of-numbers-517"></a><a name="index-identity_002c-multiplicative-518"></a>These procedures return the sum or product of their arguments.

     <pre class="example">          (+ 3 4)                 &rArr;  7
          (+ 3)                   &rArr;  3
          (+)                     &rArr;  0
          (* 4)                   &rArr;  4
          (*)                     &rArr;  1
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>-</b><var> z1 z2 <small class="dots">...</small><a name="index-g_t_002d-519"></a></var><br>
&mdash; procedure: <b>/</b><var> z1 z2 <small class="dots">...</small><a name="index-g_t_002f-520"></a></var><br>
<blockquote><p><a name="index-subtraction_002c-of-numbers-521"></a><a name="index-difference_002c-of-numbers-522"></a><a name="index-inverse_002c-additive_002c-of-number-523"></a><a name="index-division_002c-of-numbers-524"></a><a name="index-quotient_002c-of-numbers-525"></a><a name="index-inverse_002c-multiplicative_002c-of-number-526"></a>With two or more arguments, these procedures return the difference or
quotient of their arguments, associating to the left.  With one
argument, however, they return the additive or multiplicative inverse of
their argument.

     <pre class="example">          (- 3 4)                 &rArr;  -1
          (- 3 4 5)               &rArr;  -6
          (- 3)                   &rArr;  -3
          (/ 3 4 5)               &rArr;  3/20
          (/ 3)                   &rArr;  1/3
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>1+</b><var> z<a name="index-g_t1_002b-527"></a></var><br>
&mdash; procedure: <b>-1+</b><var> z<a name="index-g_t_002d1_002b-528"></a></var><br>
<blockquote><p><code>(1+ z)</code> is equivalent to <code>(+ z 1)</code>; <code>(-1+ z)</code> is
equivalent to <code>(- z 1)</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>abs</b><var> x<a name="index-abs-529"></a></var><br>
<blockquote><p><a name="index-absolute-value_002c-of-number-530"></a><a name="index-magnitude_002c-of-real-number-531"></a><code>abs</code> returns the magnitude of its argument.

     <pre class="example">          (abs -7)                &rArr;  7
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>quotient</b><var> n1 n2<a name="index-quotient-532"></a></var><br>
&mdash; procedure: <b>remainder</b><var> n1 n2<a name="index-remainder-533"></a></var><br>
&mdash; procedure: <b>modulo</b><var> n1 n2<a name="index-modulo-534"></a></var><br>
<blockquote><p><a name="index-division_002c-of-integers-535"></a><a name="index-quotient_002c-of-integers-536"></a><a name="index-remainder_002c-of-integers-537"></a><a name="index-modulus_002c-of-integers-538"></a><a name="index-integer-division-539"></a>These procedures implement number-theoretic (integer) division: for
positive integers <var>n1</var> and <var>n2</var>, if <var>n3</var> and <var>n4</var> are
integers such that
     then

     <pre class="example">          (quotient <var>n1</var> <var>n2</var>)        &rArr;  <var>n3</var>
          (remainder <var>n1</var> <var>n2</var>)       &rArr;  <var>n4</var>
          (modulo <var>n1</var> <var>n2</var>)          &rArr;  <var>n4</var>
</pre>
        <p class="noindent">For integers <var>n1</var> and <var>n2</var> with <var>n2</var> not equal to 0,

     <pre class="example">          (= <var>n1</var>
             (+ (* <var>n2</var> (quotient <var>n1</var> <var>n2</var>))
                (remainder <var>n1</var> <var>n2</var>)))
                                              &rArr;  #t
</pre>
        <p class="noindent">provided all numbers involved in that computation are exact.

        <p>The value returned by <code>quotient</code> always has the sign of the product
of its arguments.  <code>remainder</code> and <code>modulo</code> differ on negative
arguments &mdash; the <code>remainder</code> always has the sign of the dividend,
the <code>modulo</code> always has the sign of the divisor:

     <pre class="example">          (modulo 13 4)           &rArr;  1
          (remainder 13 4)        &rArr;  1
          
          (modulo -13 4)          &rArr;  3
          (remainder -13 4)       &rArr;  -1
          
          (modulo 13 -4)          &rArr;  -3
          (remainder 13 -4)       &rArr;  1
          
          (modulo -13 -4)         &rArr;  -1
          (remainder -13 -4)      &rArr;  -1
          
          (remainder -13 -4.0)    &rArr;  -1.0  <span class="roman">; inexact</span>
</pre>
        <p><a name="index-integer_002dtruncate-540"></a>Note that <code>quotient</code> is the same as <code>integer-truncate</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>integer-floor</b><var> n1 n2<a name="index-integer_002dfloor-541"></a></var><br>
&mdash; procedure: <b>integer-ceiling</b><var> n1 n2<a name="index-integer_002dceiling-542"></a></var><br>
&mdash; procedure: <b>integer-truncate</b><var> n1 n2<a name="index-integer_002dtruncate-543"></a></var><br>
&mdash; procedure: <b>integer-round</b><var> n1 n2<a name="index-integer_002dround-544"></a></var><br>
<blockquote><p>These procedures combine integer division with rounding.  For example,
the following are equivalent:

     <pre class="example">          (integer-floor <var>n1</var> <var>n2</var>)
          (floor (/ <var>n1</var> <var>n2</var>))
</pre>
        <p class="noindent">However, the former is faster and does not produce an intermediate
result.

        <p><a name="index-quotient-545"></a>Note that <code>integer-truncate</code> is the same as <code>quotient</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>integer-divide</b><var> n1 n2<a name="index-integer_002ddivide-546"></a></var><br>
&mdash; procedure: <b>integer-divide-quotient</b><var> qr<a name="index-integer_002ddivide_002dquotient-547"></a></var><br>
&mdash; procedure: <b>integer-divide-remainder</b><var> qr<a name="index-integer_002ddivide_002dremainder-548"></a></var><br>
<blockquote><p><a name="index-quotient-549"></a><a name="index-remainder-550"></a><code>integer-divide</code> is equivalent to performing both <code>quotient</code>
and <code>remainder</code> at once.  The result of <code>integer-divide</code> is an
object with two components; the procedures
<code>integer-divide-quotient</code> and <code>integer-divide-remainder</code>
select those components.  These procedures are useful when both the
quotient and remainder are needed; often computing both of these numbers
simultaneously is much faster than computing them separately.

        <p>For example, the following are equivalent:

     <pre class="example">          (lambda (n d)
            (cons (quotient n d)
                  (remainder n d)))
          
          (lambda (n d)
            (let ((qr (integer-divide n d)))
              (cons (integer-divide-quotient qr)
                    (integer-divide-remainder qr))))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>gcd</b><var> n1 <small class="dots">...</small><a name="index-gcd-551"></a></var><br>
&mdash; procedure: <b>lcm</b><var> n1 <small class="dots">...</small><a name="index-lcm-552"></a></var><br>
<blockquote><p><a name="index-greatest-common-divisor_002c-of-numbers-553"></a><a name="index-least-common-multiple_002c-of-numbers-554"></a>These procedures return the greatest common divisor or least common
multiple of their arguments.  The result is always non-negative.

     <pre class="example">          (gcd 32 -36)            &rArr;  4
          (gcd)                   &rArr;  0
          
          (lcm 32 -36)            &rArr;  288
          (lcm 32.0 -36)          &rArr;  288.0  <span class="roman">; inexact</span>
          (lcm)                   &rArr;  1
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>numerator</b><var> q<a name="index-numerator-555"></a></var><br>
&mdash; procedure: <b>denominator</b><var> q<a name="index-denominator-556"></a></var><br>
<blockquote><p>These procedures return the numerator or denominator of their argument;
the result is computed as if the argument was represented as a fraction
in lowest terms.  The denominator is always positive.  The denominator
of 0 is defined to be 1.

     <pre class="example">          (numerator (/ 6 4))  &rArr;  3
          (denominator (/ 6 4))  &rArr;  2
          (denominator (exact-&gt;inexact (/ 6 4))) &rArr; 2.0
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>floor</b><var> x<a name="index-floor-557"></a></var><br>
&mdash; procedure: <b>ceiling</b><var> x<a name="index-ceiling-558"></a></var><br>
&mdash; procedure: <b>truncate</b><var> x<a name="index-truncate-559"></a></var><br>
&mdash; procedure: <b>round</b><var> x<a name="index-round-560"></a></var><br>
<blockquote><p>These procedures return integers.  <code>floor</code> returns the largest
integer not larger than <var>x</var>.  <code>ceiling</code> returns the smallest
integer not smaller than <var>x</var>.  <code>truncate</code> returns the integer
closest to <var>x</var> whose absolute value is not larger than the absolute
value of <var>x</var>.  <code>round</code> returns the closest integer to <var>x</var>,
rounding to even when <var>x</var> is halfway between two integers.

        <p>Rationale: <code>round</code> rounds to even for consistency with the rounding
modes required by the <span class="sc">ieee</span> floating point standard.

        <p>Note: If the argument to one of these procedures is inexact, then the
result will also be inexact.  If an exact value is needed, the result
should be passed to the <code>inexact-&gt;exact</code> procedure (or use one of
the procedures below).

     <pre class="example">          (floor -4.3)          &rArr;  -5.0
          (ceiling -4.3)        &rArr;  -4.0
          (truncate -4.3)       &rArr;  -4.0
          (round -4.3)          &rArr;  -4.0
          
          (floor 3.5)           &rArr;  3.0
          (ceiling 3.5)         &rArr;  4.0
          (truncate 3.5)        &rArr;  3.0
          (round 3.5)           &rArr;  4.0  <span class="roman">; inexact</span>
          
          (round 7/2)           &rArr;  4    <span class="roman">; exact</span>
          (round 7)             &rArr;  7
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>floor-&gt;exact</b><var> x<a name="index-floor_002d_003eexact-561"></a></var><br>
&mdash; procedure: <b>ceiling-&gt;exact</b><var> x<a name="index-ceiling_002d_003eexact-562"></a></var><br>
&mdash; procedure: <b>truncate-&gt;exact</b><var> x<a name="index-truncate_002d_003eexact-563"></a></var><br>
&mdash; procedure: <b>round-&gt;exact</b><var> x<a name="index-round_002d_003eexact-564"></a></var><br>
<blockquote><p>These procedures are similar to the preceding procedures except that
they always return an exact result.  For example, the following are
equivalent

     <pre class="example">          (floor-&gt;exact x)
          (inexact-&gt;exact (floor x))
</pre>
        <p class="noindent">except that the former is faster and has fewer range restrictions. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>rationalize</b><var> x y<a name="index-rationalize-565"></a></var><br>
&mdash; procedure: <b>rationalize-&gt;exact</b><var> x y<a name="index-rationalize_002d_003eexact-566"></a></var><br>
<blockquote><p><a name="index-simplest-rational-_0028defn_0029-567"></a><a name="index-rational_002c-simplest-_0028defn_0029-568"></a><code>rationalize</code> returns the <em>simplest</em> rational number differing
from <var>x</var> by no more than <var>y</var>.  A rational number <var>r1</var> is
<em>simpler</em> than another rational number <var>r2</var> if
<var>r1</var><tt>=</tt><var>p1</var><tt>/</tt><var>q1</var> and <var>r2</var><tt>=</tt><var>p2</var><tt>/</tt><var>q2</var> (both
in lowest terms) and <tt>|</tt><var>p1</var><tt>|&lt;=|</tt><var>p2</var><tt>|</tt> and
<tt>|</tt><var>q1</var><tt>|&lt;=|</tt><var>q2</var><tt>|</tt>.  Thus <tt>3/5</tt> is simpler than <tt>4/7</tt>. 
Although not all rationals are comparable in this ordering (consider
<tt>2/7</tt> and <tt>3/5</tt>) any interval contains a rational number that is
simpler than every other rational number in that interval (the simpler
<tt>2/5</tt> lies between <tt>2/7</tt> and <tt>3/5</tt>).  Note that <tt>0=0/1</tt> is the
simplest rational of all.

     <pre class="example">          (rationalize (inexact-&gt;exact .3) 1/10)  &rArr; 1/3    <span class="roman">; exact</span>
          (rationalize .3 1/10)                   &rArr; #i1/3  <span class="roman">; inexact</span>
</pre>
        <p><code>rationalize-&gt;exact</code> is similar to <code>rationalize</code> except that
it always returns an exact result. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>simplest-rational</b><var> x y<a name="index-simplest_002drational-569"></a></var><br>
&mdash; procedure: <b>simplest-exact-rational</b><var> x y<a name="index-simplest_002dexact_002drational-570"></a></var><br>
<blockquote><p><code>simplest-rational</code> returns the simplest rational number between
<var>x</var> and <var>y</var> inclusive; <code>simplest-exact-rational</code> is similar
except that it always returns an exact result.

        <p>These procedures implement the same functionality as <code>rationalize</code>
and <code>rationalize-&gt;exact</code>, except that they specify the input range
by its endpoints; <code>rationalize</code> specifies the range by its center
point and its (half-) width. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>exp</b><var> z<a name="index-exp-571"></a></var><br>
&mdash; procedure: <b>log</b><var> z<a name="index-log-572"></a></var><br>
&mdash; procedure: <b>sin</b><var> z<a name="index-sin-573"></a></var><br>
&mdash; procedure: <b>cos</b><var> z<a name="index-cos-574"></a></var><br>
&mdash; procedure: <b>tan</b><var> z<a name="index-tan-575"></a></var><br>
&mdash; procedure: <b>asin</b><var> z<a name="index-asin-576"></a></var><br>
&mdash; procedure: <b>acos</b><var> z<a name="index-acos-577"></a></var><br>
&mdash; procedure: <b>atan</b><var> z<a name="index-atan-578"></a></var><br>
&mdash; procedure: <b>atan</b><var> y x<a name="index-atan-579"></a></var><br>
<blockquote><p><a name="index-angle-580"></a><a name="index-make_002drectangular-581"></a>These procedures compute the usual transcendental functions.  <code>log</code>
computes the natural logarithm of <var>z</var> (not the base ten logarithm). 
<code>asin</code>, <code>acos</code>, and <code>atan</code> compute arcsine, arccosine,
and arctangent, respectively.  The two-argument variant of <code>atan</code>
computes <code>(angle (make-rectangular </code><var>x</var> <var>y</var><code>))</code> (see
below).

        <p>In general, the mathematical functions log, arcsine, arccosine, and
arctangent are multiply defined.  For nonzero real <var>x</var>, the value of
log <var>x</var> is defined to be the one whose imaginary part lies in the
range minus <var>pi</var> (exclusive) to <var>pi</var> (inclusive).  log 0 is
undefined.  The value of log <var>z</var> when <var>z</var> is complex is defined
according to the formula
With log defined this way, the values of arcsine, arccosine, and
arctangent are according to the following formulae:
The above specification follows <cite>Common Lisp: the Language</cite>, which
in turn cites <cite>Principal Values and Branch Cuts in Complex APL</cite>;
refer to these sources for more detailed discussion of branch cuts,
boundary conditions, and implementation of these functions.  When it is
possible these procedures produce a real result from a real
argument. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>sqrt</b><var> z<a name="index-sqrt-582"></a></var><br>
<blockquote><p>Returns the principal square root of <var>z</var>.  The result will have
either positive real part, or zero real part and non-negative imaginary
part. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>expt</b><var> z1 z2<a name="index-expt-583"></a></var><br>
<blockquote><p>Returns <var>z1</var> raised to the power <var>z2</var>:
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>make-rectangular</b><var> x1 x2<a name="index-make_002drectangular-584"></a></var><br>
&mdash; procedure: <b>make-polar</b><var> x3 x4<a name="index-make_002dpolar-585"></a></var><br>
&mdash; procedure: <b>real-part</b><var> z<a name="index-real_002dpart-586"></a></var><br>
&mdash; procedure: <b>imag-part</b><var> z<a name="index-imag_002dpart-587"></a></var><br>
&mdash; procedure: <b>magnitude</b><var> z<a name="index-magnitude-588"></a></var><br>
&mdash; procedure: <b>angle</b><var> z<a name="index-angle-589"></a></var><br>
&mdash; procedure: <b>conjugate</b><var> z<a name="index-conjugate-590"></a></var><br>
<blockquote><p>Suppose <var>x1</var>, <var>x2</var>, <var>x3</var>, and <var>x4</var> are real numbers and
<var>z</var> is a complex number such that
     Then <code>make-rectangular</code> and <code>make-polar</code> return <var>z</var>,
<code>real-part</code> returns <var>x1</var>, <code>imag-part</code> returns <var>x2</var>,
<code>magnitude</code> returns <var>x3</var>, and <code>angle</code> returns <var>x4</var>. 
In the case of <code>angle</code>, whose value is not uniquely determined by
the preceding rule, the value returned will be the one in the range
minus <var>pi</var> (exclusive) to <var>pi</var> (inclusive).

        <p><code>conjugate</code> returns the complex conjugate of <var>z</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>exact-&gt;inexact</b><var> z<a name="index-exact_002d_003einexact-591"></a></var><br>
&mdash; procedure: <b>inexact-&gt;exact</b><var> z<a name="index-inexact_002d_003eexact-592"></a></var><br>
<blockquote><p><code>exact-&gt;inexact</code> returns an inexact representation of <var>z</var>.  The
value returned is the inexact number that is numerically closest to the
argument.  If an exact argument has no reasonably close inexact
equivalent, then a violation of an implementation restriction may be
reported; MIT/GNU Scheme signals an error of type
<code>condition-type:bad-range-argument</code> in this case. 
<a name="index-condition_002dtype_003abad_002drange_002dargument-593"></a>
<code>inexact-&gt;exact</code> returns an exact representation of <var>z</var>.  The
value returned is the exact number that is numerically closest to the
argument.  If an inexact argument has no reasonably close exact
equivalent, then a violation of an implementation restriction may be
reported; in MIT/GNU Scheme this case does not occur because all inexact
numbers are representable as exact numbers.

        <p>These procedures implement the natural one-to-one correspondence between
exact and inexact integers throughout an implementation-dependent range. 
See <a href="Implementation-restrictions.html#Implementation-restrictions">Implementation restrictions</a>. 
</p></blockquote></div>

   <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> In MIT/GNU Scheme the <code>rational?</code> procedure is the
same as <code>real?</code>, and the <code>complex?</code> procedure is the same as
<code>number?</code>.</p>

   <p class="footnote"><small>[<a name="fn-2" href="#fnd-2">2</a>]</small> MIT/GNU Scheme signals an error of type
<code>condition-type:bad-range-argument</code> in this case.</p>

   <hr></div>

   </body></html>

