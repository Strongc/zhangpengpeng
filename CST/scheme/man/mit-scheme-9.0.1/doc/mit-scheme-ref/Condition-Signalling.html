<html lang="en">
<head>
<title>Condition Signalling - MIT/GNU Scheme 9.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Error-System.html#Error-System" title="Error System">
<link rel="prev" href="Error-System.html#Error-System" title="Error System">
<link rel="next" href="Error-Messages.html#Error-Messages" title="Error Messages">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents MIT/GNU Scheme 9.0.1.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Condition-Signalling"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Error-Messages.html#Error-Messages">Error Messages</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Error-System.html#Error-System">Error System</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Error-System.html#Error-System">Error System</a>
<hr>
</div>

<h3 class="section">16.1 Condition Signalling</h3>

<p><a name="index-condition-signalling-_0028defn_0029-2773"></a><a name="index-signalling_002c-of-condition-_0028defn_0029-2774"></a><a name="index-make_002dcondition-2775"></a>Once a condition instance has been created using <code>make-condition</code>
(or any condition constructor), it can be <dfn>signalled</dfn>.  The act of
signalling a condition is separated from the act of creating the
condition to allow more flexibility in how conditions are handled.  For
example, a condition instance could be returned as the value of a
procedure, indicating that something unusual has happened, to allow the
caller to clean up some state.  The caller could then signal the
condition once it is ready.

   <p>A more important reason for having a separate condition-signalling
mechanism is that it allows <em>resignalling</em>.  When a signalled
condition has been caught by a particular handler, and the handler decides
that it doesn't want to process that particular condition, it can signal
the condition again.  This is one way to allow other handlers to get a
chance to see the condition.

<div class="defun">
&mdash; procedure: <b>error</b><var> reason argument <small class="dots">...</small><a name="index-error-2776"></a></var><br>
<blockquote><p><a name="index-REP-loop-2777"></a><a name="index-signal_002dcondition-2778"></a><a name="index-warn-2779"></a>This is the simplest and most common way to signal a condition that
requires intervention before a computation can proceed (when
intervention is not required, <code>warn</code> is more appropriate). 
<code>error</code> signals a condition (using <code>signal-condition</code>), and if
no handler for that condition alters the flow of control (by invoking a
restart, for example) it calls the procedure
<code>standard-error-handler</code>, which normally prints an error message
and stops the computation, entering an error <span class="sc">repl</span>.  Under normal
circumstances <code>error</code> will not return a value (although an
interactive debugger can be used to force this to occur).

        <p><a name="index-make_002dcondition-2780"></a><a name="index-condition_002dtype_003asimple_002derror-2781"></a>Precisely what condition is signalled depends on the first argument to
<code>error</code>.  If <var>reason</var> is a condition, then that condition is
signalled and the <var>argument</var>s are ignored.  If <var>reason</var> is a
condition type, then a new instance of this type is generated and
signalled; the <var>argument</var>s are used to generate the values of the
fields for this condition type (they are passed as the <var>field-plist</var>
argument to <code>make-condition</code>).  In the most common case, however,
<var>reason</var> is neither a condition nor a condition type, but rather a
string or symbol.  In this case a condition of type
<code>condition-type:simple-error</code> is created with the <var>message</var>
field containing the <var>reason</var> and the <var>irritants</var> field
containing the <var>argument</var>s. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>warn</b><var> reason argument <small class="dots">...</small><a name="index-warn-2782"></a></var><br>
<blockquote><p><a name="index-error-2783"></a><a name="index-signal_002dcondition-2784"></a><a name="index-condition_002dtype_003asimple_002dwarning-2785"></a>When a condition is not severe enough to warrant intervention, it is
appropriate to signal the condition with <code>warn</code> rather than
<code>error</code>.  As with <code>error</code>, <code>warn</code> first calls
<code>signal-condition</code>; the condition that is signalled is chosen
exactly as in <code>error</code> except that a condition of type
<code>condition-type:simple-warning</code> is signalled if <var>reason</var> is
neither a condition nor a condition type.  If the condition is not
handled, <code>warn</code> calls the procedure
<code>standard-warning-handler</code>, which normally prints a warning message
and continues the computation by returning from <code>warn</code>.

        <p><a name="index-muffle_002dwarning-2786"></a><code>warn</code> establishes a restart named <code>muffle-warning</code> before
calling <code>signal-condition</code>.  This allows a signal handler to
prevent the generation of the warning message by calling
<code>muffle-warning</code>.  The value of a call to <code>warn</code> is
unspecified. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>signal-condition</b><var> condition<a name="index-signal_002dcondition-2787"></a></var><br>
<blockquote><p><a name="index-generalization_002c-of-condition-types-2788"></a><a name="index-specialization_002c-of-condition-types-2789"></a><a name="index-break_002don_002dsignals-2790"></a><a name="index-bind_002ddefault_002dcondition_002dhandler-2791"></a><a name="index-bind_002dcondition_002dhandler-2792"></a>This is the fundamental operation for signalling a condition.  The
precise operation of <code>signal-condition</code> depends on the condition
type of which <var>condition</var> is an instance, the condition types set by
<code>break-on-signals</code>, and the handlers established by
<code>bind-condition-handler</code> and <code>bind-default-condition-handler</code>.

        <p><a name="index-REP-loop-2793"></a>If the <var>condition</var> is an instance of a type that is a specialization
of any of the types specified by <code>break-on-signals</code>, then a
breakpoint <span class="sc">repl</span> is initiated.  Otherwise (or when that <span class="sc">repl</span>
returns), the handlers established by <code>bind-condition-handler</code> are
checked, most recent first.  Each applicable handler is invoked, and the
search for a handler continues if the handler returns normally.  If all
applicable handlers return, then the applicable handlers established by
<code>bind-default-condition-handler</code> are checked, again most recent
first.  Finally, if no handlers apply (or all return in a normal
manner), <code>signal-condition</code> returns an unspecified value.

        <p><em>Note:</em> unlike many other systems, the MIT/GNU Scheme runtime library
does <em>not</em> establish handlers of any kind.  (However, the Edwin
text editor uses condition handlers extensively.)  Thus, calls to
<code>signal-condition</code> will return to the caller unless there are user
supplied condition handlers, as the following example shows:

     <pre class="example">          (signal-condition
           (make-condition
            condition-type:error
            (call-with-current-continuation (lambda (x) x))
            '()    <span class="roman">; no restarts</span>
            '()))  <span class="roman">; no fields</span>
          &rArr;  <span class="roman">unspecified</span>
</pre>
        </blockquote></div>

   </body></html>

