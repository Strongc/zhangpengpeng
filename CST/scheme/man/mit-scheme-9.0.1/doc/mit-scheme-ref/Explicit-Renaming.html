<html lang="en">
<head>
<title>Explicit Renaming - MIT/GNU Scheme 9.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Macros.html#Macros" title="Macros">
<link rel="prev" href="Syntactic-Closures.html#Syntactic-Closures" title="Syntactic Closures">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents MIT/GNU Scheme 9.0.1.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Explicit-Renaming"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="Syntactic-Closures.html#Syntactic-Closures">Syntactic Closures</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Macros.html#Macros">Macros</a>
<hr>
</div>

<h4 class="subsection">2.11.4 Explicit Renaming</h4>

<p><a name="index-explicit-renaming-400"></a><dfn>Explicit renaming</dfn> is an alternative facility for defining macro
transformers.  In the MIT/GNU Scheme implementation, explicit-renaming
transformers are implemented as an abstraction layer on top of syntactic
closures.  An explicit-renaming macro transformer is defined by an
instance of the <code>er-macro-transformer</code> keyword:

<div class="defun">
&mdash; special form: <b>er-macro-transformer</b><var> expression<a name="index-er_002dmacro_002dtransformer-401"></a></var><br>
<blockquote><p>The <var>expression</var> is expanded in the syntactic environment of the
<code>er-macro-transformer</code> expression, and the expanded expression is
evaluated in the transformer environment to yield a macro transformer as
described below.  This macro transformer is bound to a macro keyword by
the special form in which the <code>transformer</code> expression appears (for
example, <code>let-syntax</code>).

        <p><a name="index-macro-transformer-402"></a><a name="index-input-form_002c-to-macro-403"></a>In the explicit-renaming facility, a <dfn>macro transformer</dfn> is a
procedure that takes three arguments, a form, a renaming procedure, and
a comparison predicate, and returns a new form.  The first argument, the
<dfn>input form</dfn>, is the form in which the macro keyword occurred.

        <p><a name="index-renaming-procedure-404"></a>The second argument to a transformation procedure is a <dfn>renaming
procedure</dfn> that takes the representation of an identifier as its
argument and returns the representation of a fresh identifier that
occurs nowhere else in the program.  For example, the transformation
procedure for a simplified version of the <code>let</code> macro might be
written as

     <pre class="example">          (lambda (exp rename compare)
            (let ((vars (map car (cadr exp)))
                  (inits (map cadr (cadr exp)))
                  (body (cddr exp)))
              `((lambda ,vars ,@body)
                ,@inits)))
</pre>
        <p class="noindent">This would not be hygienic, however.  A hygienic <code>let</code> macro must
rename the identifier <code>lambda</code> to protect it from being captured by
a local binding.  The renaming effectively creates an fresh alias for
<code>lambda</code>, one that cannot be captured by any subsequent binding:

     <pre class="example">          (lambda (exp rename compare)
            (let ((vars (map car (cadr exp)))
                  (inits (map cadr (cadr exp)))
                  (body (cddr exp)))
              `((,(rename 'lambda) ,vars ,@body)
                ,@inits)))
</pre>
        <p>The expression returned by the transformation procedure will be expanded
in the syntactic environment obtained from the syntactic environment of
the macro application by binding any fresh identifiers generated by the
renaming procedure to the denotations of the original identifiers in the
syntactic environment in which the macro was defined.  This means that a
renamed identifier will denote the same thing as the original identifier
unless the transformation procedure that renamed the identifier placed
an occurrence of it in a binding position.

        <p>The renaming procedure acts as a mathematical function in the sense that
the identifiers obtained from any two calls with the same argument will
be the same in the sense of <code>eqv?</code>.  It is an error if the renaming
procedure is called after the transformation procedure has returned.

        <p><a name="index-comparison-predicate-405"></a>The third argument to a transformation procedure is a <dfn>comparison
predicate</dfn> that takes the representations of two identifiers as its
arguments and returns true if and only if they denote the same thing in
the syntactic environment that will be used to expand the transformed
macro application.  For example, the transformation procedure for a
simplified version of the <code>cond</code> macro can be written as

     <pre class="example">          (lambda (exp rename compare)
            (let ((clauses (cdr exp)))
              (if (null? clauses)
                  `(,(rename 'quote) unspecified)
                  (let* ((first (car clauses))
                         (rest (cdr clauses))
                         (test (car first)))
                    (cond ((and (identifier? test)
                                (compare test (rename 'else)))
                           `(,(rename 'begin) ,@(cdr first)))
                          (else `(,(rename 'if)
                                  ,test
                                   (,(rename 'begin) ,@(cdr first))
                                   (cond ,@rest))))))))))
</pre>
        <p class="noindent">In this example the identifier <code>else</code> is renamed before being passed
to the comparison predicate, so the comparison will be true if and
only if the test expression is an identifier that denotes the same
thing in the syntactic environment of the expression being transformed
as <code>else</code> denotes in the syntactic environment in which the <code>cond</code>
macro was defined.  If <code>else</code> were not renamed before being passed to
the comparison predicate, then it would match a local variable that
happened to be named <code>else</code>, and the macro would not be hygienic.

        <p>Some macros are non-hygienic by design.  For example, the following
defines a <code>loop</code> macro that implicitly binds <code>exit</code> to an
escape procedure.  The binding of <code>exit</code> is intended to capture
free references to <code>exit</code> in the body of the loop, so <code>exit</code>
is not renamed.

     <pre class="example">          (define-syntax loop
            (er-macro-transformer
             (lambda (x r c)
               (let ((body (cdr x)))
                 `(,(r 'call-with-current-continuation)
                   (,(r 'lambda) (exit)
                    (,(r 'let) ,(r 'f) () ,@body (,(r 'f)))))))))
</pre>
        <p>Suppose a <code>while</code> macro is implemented using <code>loop</code>, with the
intent that <code>exit</code> may be used to escape from the <code>while</code>
loop.  The <code>while</code> macro cannot be written as

     <pre class="example">          (define-syntax while
            (syntax-rules ()
              ((while test body ...)
               (loop (if (not test) (exit #f))
                     body ...))))
</pre>
        <p class="noindent">because the reference to <code>exit</code> that is inserted by the
<code>while</code> macro is intended to be captured by the binding of
<code>exit</code> that will be inserted by the <code>loop</code> macro.  In other
words, this <code>while</code> macro is not hygienic.  Like <code>loop</code>, it
must be written using the <code>er-macro-transformer</code> syntax:

     <pre class="example">          (define-syntax while
            (er-macro-transformer
             (lambda (x r c)
               (let ((test (cadr x))
                     (body (cddr x)))
                 `(,(r 'loop)
                   (,(r 'if) (,(r 'not) ,test) (exit #f))
                   ,@body)))))
</pre>
        </blockquote></div>

   </body></html>

