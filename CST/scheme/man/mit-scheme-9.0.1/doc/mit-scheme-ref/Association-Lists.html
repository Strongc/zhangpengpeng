<html lang="en">
<head>
<title>Association Lists - MIT/GNU Scheme 9.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Associations.html#Associations" title="Associations">
<link rel="prev" href="Associations.html#Associations" title="Associations">
<link rel="next" href="1D-Tables.html#g_t1D-Tables" title="1D Tables">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents MIT/GNU Scheme 9.0.1.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Association-Lists"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="1D-Tables.html#g_t1D-Tables">1D Tables</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Associations.html#Associations">Associations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Associations.html#Associations">Associations</a>
<hr>
</div>

<h3 class="section">11.1 Association Lists</h3>

<!-- **** begin CLTL **** -->
<p><a name="index-association-list-_0028defn_0029-1583"></a><a name="index-list_002c-association-_0028defn_0029-1584"></a><a name="index-alist-_0028defn_0029-1585"></a><a name="index-key_002c-of-association-list-element-_0028defn_0029-1586"></a>An <dfn>association list</dfn>, or <dfn>alist</dfn>, is a data structure used very
frequently in Scheme.  An alist is a list of pairs, each of which is
called an <dfn>association</dfn>.  The car of an association is called the
<dfn>key</dfn>.

   <p>An advantage of the alist representation is that an alist can be
incrementally augmented simply by adding new entries to the front. 
Moreover, because the searching procedures <code>assv</code> et al. search the
alist in order, new entries can &ldquo;shadow&rdquo; old entries.  If an alist is
viewed as a mapping from keys to data, then the mapping can be not only
augmented but also altered in a non-destructive manner by adding new
entries to the front of the alist.<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>
<!-- **** end CLTL **** -->

<div class="defun">
&mdash; procedure: <b>alist?</b><var> object<a name="index-alist_003f-1587"></a></var><br>
<blockquote><p><a name="index-type-predicate_002c-for-alist-1588"></a><a name="index-list_003f-1589"></a>Returns <code>#t</code> if <var>object</var> is an association list (including the
empty list); otherwise returns <code>#f</code>.  Any <var>object</var> satisfying this
predicate also satisfies <code>list?</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>assq</b><var> object alist<a name="index-assq-1590"></a></var><br>
&mdash; procedure: <b>assv</b><var> object alist<a name="index-assv-1591"></a></var><br>
&mdash; procedure: <b>assoc</b><var> object alist<a name="index-assoc-1592"></a></var><br>
<blockquote><p><a name="index-searching_002c-of-alist-1593"></a><a name="index-eq_003f-1594"></a><a name="index-eqv_003f-1595"></a><a name="index-equal_003f-1596"></a>These procedures find the first pair in <var>alist</var> whose car field is
<var>object</var>, and return that pair; the returned pair is always an
<em>element</em> of <var>alist</var>, <em>not</em> one of the pairs from which
<var>alist</var> is composed.  If no pair in <var>alist</var> has <var>object</var> as
its car, <code>#f</code> (n.b.: not the empty list) is returned.  <code>assq</code>
uses <code>eq?</code> to compare <var>object</var> with the car fields of the pairs
in <var>alist</var>, while <code>assv</code> uses <code>eqv?</code> and <code>assoc</code> uses
<code>equal?</code>.<a rel="footnote" href="#fn-2" name="fnd-2"><sup>2</sup></a>

     <pre class="example">          (define e '((a 1) (b 2) (c 3)))
          (assq 'a e)                             &rArr;  (a 1)
          (assq 'b e)                             &rArr;  (b 2)
          (assq 'd e)                             &rArr;  #f
          (assq (list 'a) '(((a)) ((b)) ((c))))   &rArr;  #f
          (assoc (list 'a) '(((a)) ((b)) ((c))))  &rArr;  ((a))
          (assq 5 '((2 3) (5 7) (11 13)))         &rArr;  <span class="roman">unspecified</span>
          (assv 5 '((2 3) (5 7) (11 13)))         &rArr;  (5 7)
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>association-procedure</b><var> predicate selector<a name="index-association_002dprocedure-1597"></a></var><br>
<blockquote><p>Returns an association procedure that is similar to <code>assv</code>, except
that <var>selector</var> (a procedure of one argument) is used to select the
key from the association, and <var>predicate</var> (an equivalence predicate)
is used to compare the key to the given item.  This can be used to make
association lists whose elements are, say, vectors instead of pairs
(also see <a href="Searching-Lists.html#Searching-Lists">Searching Lists</a>).

        <p>For example, here is how <code>assv</code> could be implemented:

     <pre class="example">          (define assv (association-procedure eqv? car))
</pre>
        <p>Another example is a &ldquo;reverse association&rdquo; procedure:

     <pre class="example">          (define rassv (association-procedure eqv? cdr))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>del-assq</b><var> object alist<a name="index-del_002dassq-1598"></a></var><br>
&mdash; procedure: <b>del-assv</b><var> object alist<a name="index-del_002dassv-1599"></a></var><br>
&mdash; procedure: <b>del-assoc</b><var> object alist<a name="index-del_002dassoc-1600"></a></var><br>
<blockquote><p><a name="index-deletion_002c-of-alist-element-1601"></a><a name="index-eq_003f-1602"></a><a name="index-eqv_003f-1603"></a><a name="index-equal_003f-1604"></a>These procedures return a newly allocated copy of <var>alist</var> in which
all associations with keys equal to <var>object</var> have been removed. 
Note that while the returned copy is a newly allocated list, the
association pairs that are the elements of the list are shared with
<var>alist</var>, not copied.  <code>del-assq</code> uses <code>eq?</code> to compare
<var>object</var> with the keys, while <code>del-assv</code> uses <code>eqv?</code> and
<code>del-assoc</code> uses <code>equal?</code>.

     <pre class="example">          (define a
            '((butcher . "231 e22nd St.")
              (baker . "515 w23rd St.")
              (hardware . "988 Lexington Ave.")))
          
          (del-assq 'baker a)
               &rArr;
               ((butcher . "231 e22nd St.")
                (hardware . "988 Lexington Ave."))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>del-assq!</b><var> object alist<a name="index-del_002dassq_0021-1605"></a></var><br>
&mdash; procedure: <b>del-assv!</b><var> object alist<a name="index-del_002dassv_0021-1606"></a></var><br>
&mdash; procedure: <b>del-assoc!</b><var> object alist<a name="index-del_002dassoc_0021-1607"></a></var><br>
<blockquote><p><a name="index-eq_003f-1608"></a><a name="index-eqv_003f-1609"></a><a name="index-equal_003f-1610"></a>These procedures remove from <var>alist</var> all associations with keys
equal to <var>object</var>.  They return the resulting list. 
<code>del-assq!</code> uses <code>eq?</code> to compare <var>object</var> with the keys,
while <code>del-assv!</code> uses <code>eqv?</code> and <code>del-assoc!</code> uses
<code>equal?</code>.  These procedures are like <code>del-assq</code>,
<code>del-assv</code>, and <code>del-assoc</code>, respectively, except that they
destructively modify <var>alist</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>delete-association-procedure</b><var> deletor predicate selector<a name="index-delete_002dassociation_002dprocedure-1611"></a></var><br>
<blockquote><p><a name="index-list_002ddeletor-1612"></a><a name="index-list_002ddeletor_0021-1613"></a>This returns a deletion procedure similar to <code>del-assv</code> or
<code>del-assq!</code>.  The <var>predicate</var> and <var>selector</var> arguments are
the same as those for <code>association-procedure</code>, while the
<var>deletor</var> argument should be either the procedure
<code>list-deletor</code> (for non-destructive deletions), or the procedure
<code>list-deletor!</code> (for destructive deletions).

        <p>For example, here is a possible implementation of <code>del-assv</code>:

     <pre class="example">          (define del-assv
            (delete-association-procedure list-deletor eqv? car))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>alist-copy</b><var> alist<a name="index-alist_002dcopy-1614"></a></var><br>
<blockquote><p><a name="index-copying_002c-of-alist-1615"></a><a name="index-list_002dcopy-1616"></a>Returns a newly allocated copy of <var>alist</var>.  This is similar to
<code>list-copy</code> except that the &ldquo;association&rdquo; pairs, i.e. the
elements of the list <var>alist</var>, are also copied.  <code>alist-copy</code>
could have been implemented like this:

     <pre class="example">          (define (alist-copy alist)
            (if (null? alist)
                '()
                (cons (cons (car (car alist)) (cdr (car alist)))
                      (alist-copy (cdr alist)))))
</pre>
        </blockquote></div>

   <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> This introduction is taken
from <cite>Common Lisp, The Language</cite>, second edition, p. 431.</p>

   <p class="footnote"><small>[<a name="fn-2" href="#fnd-2">2</a>]</small> Although they are often used as predicates,
<code>assq</code>, <code>assv</code>, and <code>assoc</code> do not have question marks in
their names because they return useful values rather than just <code>#t</code>
or <code>#f</code>.</p>

   <hr></div>

   </body></html>

