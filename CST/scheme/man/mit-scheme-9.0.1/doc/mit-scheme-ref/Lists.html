<html lang="en">
<head>
<title>Lists - MIT/GNU Scheme 9.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="Strings.html#Strings" title="Strings">
<link rel="next" href="Vectors.html#Vectors" title="Vectors">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents MIT/GNU Scheme 9.0.1.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Lists"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Vectors.html#Vectors">Vectors</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Strings.html#Strings">Strings</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<h2 class="chapter">7 Lists</h2>

<p><a name="index-pair-_0028defn_0029-1091"></a><a name="index-dotted-pair-_0028see-pair_0029-1092"></a><a name="index-car-field_002c-of-pair-_0028defn_0029-1093"></a><a name="index-cdr-field_002c-of-pair-_0028defn_0029-1094"></a>A <dfn>pair</dfn> (sometimes called a <dfn>dotted pair</dfn>) is a data structure
with two fields called the <dfn>car</dfn> and <dfn>cdr</dfn> fields (for
historical reasons).  Pairs are created by the procedure <code>cons</code>. 
The car and cdr fields are accessed by the procedures <code>car</code> and
<code>cdr</code>.  The car and cdr fields are assigned by the procedures
<code>set-car!</code> and <code>set-cdr!</code>.

   <p><a name="index-list-_0028defn_0029-1095"></a>Pairs are used primarily to represent <dfn>lists</dfn>.  A list can be
defined recursively as either the empty list or a pair whose cdr is
a list.  More precisely, the set of lists is defined as the smallest set
<var>X</var> such that

     <ul>
<li>The empty list is in <var>X</var>.

     <li>If <var>list</var> is in <var>X</var>, then any pair whose cdr field contains
<var>list</var> is also in <var>X</var>. 
</ul>

   <p><a name="index-element_002c-of-list-_0028defn_0029-1096"></a><a name="index-length_002c-of-list-_0028defn_0029-1097"></a><a name="index-empty-list-_0028defn_0029-1098"></a>The objects in the car fields of successive pairs of a list are the
<dfn>elements</dfn> of the list.  For example, a two-element list is a pair
whose car is the first element and whose cdr is a pair whose car is the
second element and whose cdr is the empty list.  The <dfn>length</dfn> of a
list is the number of elements, which is the same as the number of
pairs.  The <dfn>empty list</dfn> is a special object of its own type (it is
not a pair); it has no elements and its length is zero.<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>

   <p><a name="index-dotted-notation_002c-for-pair-_0028defn_0029-1099"></a><a name="index-notation_002c-dotted-_0028defn_0029-1100"></a><a name="index-external-representation_002c-for-pair-1101"></a><a name="index-pair_002c-external-representation-1102"></a><a name="index-g_t_0028-as-external-representation-1103"></a><a name="index-g_t_0029-as-external-representation-1104"></a><a name="index-g_t_002e-as-external-representation-1105"></a><a name="index-parenthesis_002c-as-external-representation-1106"></a><a name="index-dot_002c-as-external-representation-1107"></a><a name="index-period_002c-as-external-representation-1108"></a><a name="index-g_t_0028-1109"></a><a name="index-g_t_0029-1110"></a><a name="index-g_t_002e-1111"></a>The most general notation (external representation) for Scheme pairs is
the &ldquo;dotted&rdquo; notation <code>(</code><var>c1</var><code> . </code><var>c2</var><code>)</code> where <var>c1</var> is
the value of the car field and <var>c2</var> is the value of the cdr field. 
For example, <code>(4 . 5)</code> is a pair whose car is <code>4</code> and whose
cdr is <code>5</code>.  Note that <code>(4 . 5)</code> is the external
representation of a pair, not an expression that evaluates to a pair.

   <p><a name="index-external-representation_002c-for-list-1112"></a><a name="index-list_002c-external-representation-1113"></a><a name="index-external-representation_002c-for-empty-list-1114"></a><a name="index-empty-list_002c-external-representation-1115"></a><a name="index-g_t_0028_0029-1116"></a>A more streamlined notation can be used for lists: the elements of the
list are simply enclosed in parentheses and separated by spaces.  The
empty list is written <code>()</code>.  For example, the following are
equivalent notations for a list of symbols:

<pre class="example">     (a b c d e)
     (a . (b . (c . (d . (e . ())))))
</pre>
   <p><a name="index-set_002dcdr_0021-1117"></a>Whether a given pair is a list depends upon what is stored in the cdr
field.  When the <code>set-cdr!</code> procedure is used, an object can be a
list one moment and not the next:

<pre class="example">     (define x (list 'a 'b 'c))
     (define y x)
     y                                       &rArr; (a b c)
     (list? y)                               &rArr; #t
     (set-cdr! x 4)                          &rArr; <span class="roman">unspecified</span>
     x                                       &rArr; (a . 4)
     (eqv? x y)                              &rArr; #t
     y                                       &rArr; (a . 4)
     (list? y)                               &rArr; #f
     (set-cdr! x x)                          &rArr; <span class="roman">unspecified</span>
     (list? y)                               &rArr; #f
</pre>
   <p><a name="index-improper-list-_0028defn_0029-1118"></a><a name="index-list_002c-improper-_0028defn_0029-1119"></a>A chain of pairs that doesn't end in the empty list is called an
<dfn>improper list</dfn>.  Note that an improper list is not a list.  The
list and dotted notations can be combined to represent improper lists,
as the following equivalent notations show:

<pre class="example">     (a b c . d)
     (a . (b . (c . d)))
</pre>
   <p><a name="index-quote-1120"></a><a name="index-quasiquote-1121"></a><a name="index-unquote-1122"></a><a name="index-unquote_002dsplicing-1123"></a><a name="index-g_t_0027-1124"></a><a name="index-g_t_0060-1125"></a><a name="index-g_t_002c-1126"></a><a name="index-g_t_002c_0040_0040-1127"></a><a name="index-read-1128"></a>Within literal expressions and representations of objects read by the
<code>read</code> procedure, the forms <code>'</code><var>datum</var>,
<code>`</code><var>datum</var>, <code>,</code><var>datum</var>, and <code>,@</code><var>datum</var>
denote two-element lists whose first elements are the symbols
<code>quote</code>, <code>quasiquote</code>, <code>unquote</code>, and
<code>unquote-splicing</code>, respectively.  The second element in each case
is <var>datum</var>.  This convention is supported so that arbitrary Scheme
programs may be represented as lists.  Among other things, this permits
the use of the <code>read</code> procedure to parse Scheme programs.

<ul class="menu">
<li><a accesskey="1" href="Pairs.html#Pairs">Pairs</a>
<li><a accesskey="2" href="Construction-of-Lists.html#Construction-of-Lists">Construction of Lists</a>
<li><a accesskey="3" href="Selecting-List-Components.html#Selecting-List-Components">Selecting List Components</a>
<li><a accesskey="4" href="Cutting-and-Pasting-Lists.html#Cutting-and-Pasting-Lists">Cutting and Pasting Lists</a>
<li><a accesskey="5" href="Filtering-Lists.html#Filtering-Lists">Filtering Lists</a>
<li><a accesskey="6" href="Searching-Lists.html#Searching-Lists">Searching Lists</a>
<li><a accesskey="7" href="Mapping-of-Lists.html#Mapping-of-Lists">Mapping of Lists</a>
<li><a accesskey="8" href="Reduction-of-Lists.html#Reduction-of-Lists">Reduction of Lists</a>
<li><a accesskey="9" href="Miscellaneous-List-Operations.html#Miscellaneous-List-Operations">Miscellaneous List Operations</a>
</ul>

   <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> The
above definitions imply that all lists have finite length and are
terminated by the empty list.</p>

   <hr></div>

   </body></html>

