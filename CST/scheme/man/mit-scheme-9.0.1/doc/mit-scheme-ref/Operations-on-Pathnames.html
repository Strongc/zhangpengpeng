<html lang="en">
<head>
<title>Operations on Pathnames - MIT/GNU Scheme 9.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Pathnames.html#Pathnames" title="Pathnames">
<link rel="prev" href="Components-of-Pathnames.html#Components-of-Pathnames" title="Components of Pathnames">
<link rel="next" href="Miscellaneous-Pathnames.html#Miscellaneous-Pathnames" title="Miscellaneous Pathnames">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents MIT/GNU Scheme 9.0.1.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Operations-on-Pathnames"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Miscellaneous-Pathnames.html#Miscellaneous-Pathnames">Miscellaneous Pathnames</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Components-of-Pathnames.html#Components-of-Pathnames">Components of Pathnames</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Pathnames.html#Pathnames">Pathnames</a>
<hr>
</div>

<h4 class="subsection">15.1.3 Operations on Pathnames</h4>

<div class="defun">
&mdash; procedure: <b>pathname?</b><var> object<a name="index-pathname_003f-2524"></a></var><br>
<blockquote><p><a name="index-type-predicate_002c-for-pathname-2525"></a>Returns <code>#t</code> if <var>object</var> is a pathname; otherwise returns
<code>#f</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>pathname=?</b><var> pathname1 pathname2<a name="index-pathname_003d_003f-2526"></a></var><br>
<blockquote><p><a name="index-equivalence-predicate_002c-for-pathnames-2527"></a>Returns <code>#t</code> if <var>pathname1</var> is equivalent to <var>pathname2</var>;
otherwise returns <code>#f</code>. 
Pathnames are equivalent if all of their components are equivalent,
hence two pathnames that are equivalent must identify the same file or
equivalent partial pathnames. 
However, the converse is not true: non-equivalent pathnames may specify
the same file (e.g. via absolute and relative directory components),
and pathnames that specify no file at all (e.g. name and directory
components unspecified) may be equivalent. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>pathname-absolute?</b><var> pathname<a name="index-pathname_002dabsolute_003f-2528"></a></var><br>
<blockquote><p>Returns <code>#t</code> if <var>pathname</var> is an absolute rather than relative
pathname object; otherwise returns <code>#f</code>.  Specifically, this
procedure returns <code>#t</code> when the directory component of
<var>pathname</var> is a list starting with the symbol <code>absolute</code>, and
returns <code>#f</code> in all other cases.  All pathnames are either absolute
or relative, so if this procedure returns <code>#f</code>, the argument is a
relative pathname. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>directory-pathname?</b><var> pathname<a name="index-directory_002dpathname_003f-2529"></a></var><br>
<blockquote><p>Returns <code>#t</code> if <var>pathname</var> has only directory components and no
file components.  This is roughly equivalent to

     <pre class="example">          (define (directory-pathname? pathname)
            (string-null? (file-namestring pathname)))
</pre>
        <p class="noindent">except that it is faster. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>pathname-wild?</b><var> pathname<a name="index-pathname_002dwild_003f-2530"></a></var><br>
<blockquote><p>Returns <code>#t</code> if <var>pathname</var> contains any wildcard components;
otherwise returns <code>#f</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>merge-pathnames</b><var> pathname </var>[<var>defaults </var>[<var>default-version</var>]]<var><a name="index-merge_002dpathnames-2531"></a></var><br>
<blockquote><p><a name="index-merging_002c-of-pathnames-2532"></a><a name="index-defaulting_002c-of-pathname-2533"></a>Returns a pathname whose components are obtained by combining those of
<var>pathname</var> and <var>defaults</var>.  <var>Defaults</var> defaults to the value
of <code>*default-pathname-defaults*</code> and <var>default-version</var> defaults
to <code>newest</code>.

        <p>The pathnames are combined by components: if <var>pathname</var> has a
non-missing component, that is the resulting component, otherwise the
component from <var>defaults</var> is used. 
The default version can be <code>#f</code> to preserve the information that
the component was missing from <var>pathname</var>. 
The directory component is handled specially: if both pathnames have
directory components that are lists, and the directory component from
<var>pathname</var> is relative (i.e. starts with <code>relative</code>), then the
resulting directory component is formed by appending <var>pathname</var>'s
component to <var>defaults</var>'s component. 
For example:

     <pre class="example">          (define path1 (-&gt;pathname "scheme/foo.scm"))
          (define path2 (-&gt;pathname "/usr/morris"))
          path1
               &rArr;  #[pathname 74 "scheme/foo.scm"]
          path2
               &rArr;  #[pathname 75 "/usr/morris"]
          (merge-pathnames path1 path2)
               &rArr;  #[pathname 76 "/usr/scheme/foo.scm"]
          (merge-pathnames path2 path1)
               &rArr;  #[pathname 77 "/usr/morris.scm"]
</pre>
        <p>The merging rules for the version are more complex and depend on whether
<var>pathname</var> specifies a name.  If <var>pathname</var> does not specify a
name, then the version, if not provided, will come from <var>defaults</var>. 
However, if <var>pathname</var> does specify a name then the version is not
affected by <var>defaults</var>.  The reason is that the version &ldquo;belongs
to&rdquo; some other file name and is unlikely to have anything to do with
the new one.  Finally, if this process leaves the version missing, then
<var>default-version</var> is used.

        <p>The net effect is that if the user supplies just a name, then the host,
device, directory and type will come from <var>defaults</var>, but the
version will come from <var>default-version</var>.  If the user supplies
nothing, or just a directory, the name, type and version will come over
from <var>defaults</var> together. 
</p></blockquote></div>

<div class="defun">
&mdash; variable: <b>*default-pathname-defaults*</b><var><a name="index-g_t_002adefault_002dpathname_002ddefaults_002a-2534"></a></var><br>
<blockquote><p><a name="index-defaulting_002c-of-pathname-2535"></a>This is the default pathname-defaults pathname; if any pathname
primitive that needs a set of defaults is not given one, it uses this
one.  <code>set-working-directory-pathname!</code> sets this variable to a new
value, computed by merging the new working directory with the variable's
old value. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>pathname-default</b><var> pathname device directory name type version<a name="index-pathname_002ddefault-2536"></a></var><br>
<blockquote><p>This procedure defaults all of the components of <var>pathname</var>
simultaneously.  It could have been defined by:

     <pre class="example">          (define (pathname-default pathname
                                    device directory name type version)
            (make-pathname (pathname-host pathname)
                           (or (pathname-device pathname) device)
                           (or (pathname-directory pathname) directory)
                           (or (pathname-name pathname) name)
                           (or (pathname-type pathname) type)
                           (or (pathname-version pathname) version)))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>file-namestring</b><var> pathname<a name="index-file_002dnamestring-2537"></a></var><br>
&mdash; procedure: <b>directory-namestring</b><var> pathname<a name="index-directory_002dnamestring-2538"></a></var><br>
&mdash; procedure: <b>host-namestring</b><var> pathname<a name="index-host_002dnamestring-2539"></a></var><br>
&mdash; procedure: <b>enough-namestring</b><var> pathname </var>[<var>defaults</var>]<var><a name="index-enough_002dnamestring-2540"></a></var><br>
<blockquote><p><a name="index-conversion_002c-pathname-to-string-2541"></a>These procedures return a string corresponding to a subset of the
<var>pathname</var> information.  <code>file-namestring</code> returns a string
representing just the <var>name</var>, <var>type</var> and <var>version</var>
components of <var>pathname</var>; the result of <code>directory-namestring</code>
represents just the <var>host</var>, <var>device</var>, and <var>directory</var>
components; and <code>host-namestring</code> returns a string for just the
<var>host</var> portion.

        <p><code>enough-namestring</code> takes another argument, <var>defaults</var>. 
It returns an abbreviated namestring that is just sufficient to identify
the file named by <var>pathname</var> when considered relative to the
<var>defaults</var> (which defaults to <code>*default-pathname-defaults*</code>).

     <pre class="example">          (file-namestring "/usr/morris/minor.van")
               &rArr;  "minor.van"
          (directory-namestring "/usr/morris/minor.van")
               &rArr;  "/usr/morris/"
          (enough-namestring "/usr/morris/men")
               &rArr;  "men"      <span class="roman">;perhaps</span>
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>file-pathname</b><var> pathname<a name="index-file_002dpathname-2542"></a></var><br>
&mdash; procedure: <b>directory-pathname</b><var> pathname<a name="index-directory_002dpathname-2543"></a></var><br>
&mdash; procedure: <b>enough-pathname</b><var> pathname </var>[<var>defaults</var>]<var><a name="index-enough_002dpathname-2544"></a></var><br>
<blockquote><p><a name="index-selection_002c-components-of-pathname-2545"></a>These procedures return a pathname corresponding to a subset of the
<var>pathname</var> information. 
<code>file-pathname</code> returns a pathname with just the
<var>name</var>, <var>type</var> and <var>version</var> components of <var>pathname</var>. 
The result of <code>directory-pathname</code> is a pathname containing the
<var>host</var>, <var>device</var> and <var>directory</var> components of <var>pathname</var>.

        <p><code>enough-pathname</code> takes another argument, <var>defaults</var>. 
It returns an abbreviated pathname that is just sufficient to identify
the file named by <var>pathname</var> when considered relative to the
<var>defaults</var> (which defaults to <code>*default-pathname-defaults*</code>).

        <p>These procedures are similar to <code>file-namestring</code>,
<code>directory-namestring</code> and <code>enough-namestring</code>, but they
return pathnames instead of strings. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>directory-pathname-as-file</b><var> pathname<a name="index-directory_002dpathname_002das_002dfile-2546"></a></var><br>
<blockquote><p><a name="index-file_002c-converting-pathname-directory-to-2547"></a>Returns a pathname that is equivalent to <var>pathname</var>, but in which
the directory component is represented as a file. 
The last directory is removed from the directory component and converted
into name and type components. 
This is the inverse operation to <code>pathname-as-directory</code>.

     <pre class="example">          (directory-pathname-as-file (-&gt;pathname "/usr/blisp/"))
               &rArr;  #[pathname "/usr/blisp"]
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>pathname-as-directory</b><var> pathname<a name="index-pathname_002das_002ddirectory-2548"></a></var><br>
<blockquote><p><a name="index-directory_002c-converting-pathname-to-2549"></a>Returns a pathname that is equivalent to <var>pathname</var>, but in which
any file components have been converted to a directory component.  If
<var>pathname</var> does not have name, type, or version components, it is
returned without modification.  Otherwise, these file components are
converted into a string, and the string is added to the end of the list
of directory components.  This is the inverse operation to
<code>directory-pathname-as-file</code>.

     <pre class="example">          (pathname-as-directory (-&gt;pathname "/usr/blisp/rel5"))
               &rArr;  #[pathname "/usr/blisp/rel5/"]
</pre>
        </blockquote></div>

   </body></html>

