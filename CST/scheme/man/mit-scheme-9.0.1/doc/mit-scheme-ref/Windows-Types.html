<html lang="en">
<head>
<title>Windows Types - MIT/GNU Scheme 9.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Foreign-function-interface.html#Foreign-function-interface" title="Foreign function interface">
<link rel="prev" href="Foreign-function-interface.html#Foreign-function-interface" title="Foreign function interface">
<link rel="next" href="Windows-Foreign-Procedures.html#Windows-Foreign-Procedures" title="Windows Foreign Procedures">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents MIT/GNU Scheme 9.0.1.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Windows-Types"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Windows-Foreign-Procedures.html#Windows-Foreign-Procedures">Windows Foreign Procedures</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Foreign-function-interface.html#Foreign-function-interface">Foreign function interface</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Foreign-function-interface.html#Foreign-function-interface">Foreign function interface</a>
<hr>
</div>

<h4 class="subsection">18.2.1 Windows Types</h4>

<p><a name="index-Windows-types-3119"></a><a name="index-foreign-type-declarations-3120"></a><a name="index-types_002c-Windows-3121"></a><a name="index-defining-foreign-types-3122"></a>Foreign types are designed to represent a correspondence between a
Scheme data type that is used to represent an object within the Scheme
world and a C data type that represents the data object in the C world. 
Thus we cannot manipulate true C objects in Scheme, nor can we
manipulate Scheme objects in C.

   <p>Each foreign type has four aspects that together ensure that the
correspondence between the Scheme and C objects is maintained.  These
aspects are all encoded as procedures that either check for validity or
convert between representations.  Thus a foreign type is not a
declarative type so much as a procedural description of how to pass the
type.  The underlying foreign procedure call mechanism can pass integers
and vector-like Scheme objects, and returns integer values.  All other
objects must be translated into integers or some other basic type, and
must be recovered from integers.

   <p>The aspects are:

     <dl>
<dt><var>check</var><dd>A predicate that returns <code>#t</code> if the argument is of an acceptable
Scheme type, otherwise returns <code>#f</code>. 
The <var>check</var> procedure is used for type-checking.

     <br><dt><var>convert</var><dd>A procedure of one argument which returns a Scheme object of one of the
basic types. 
It is used to convert an object into a `simpler' object that will
eventually be converted into a C object. 
The legal simpler objects are integers and strings.

     <br><dt><var>return-convert</var><dd>A procedure of one argument that, given an integer, returns a Scheme
object of a type satisfying <var>check</var>. 
Its purpose is to convert the result returned by the foreign procedure
into a Scheme value.

     <br><dt><var>revert</var><dd>Some C procedures modify one or more of their arguments.  These
arguments are passed by reference, i.e. as a pointer to their address. 
Since a Scheme object might have a different memory layout and storage
conventions, it must be passed by copy-in and copy-out rather than by
reference. 
<var>Revert</var> is a procedure of two parameters, the original object
passed and the result of <var>convert</var> on that object. 
<var>Revert</var> may then inspect the converted object and copy back the
changes to the original.

   </dl>

<div class="defun">
&mdash; special form: <b>define-windows-type</b><var> name check convert return revert<a name="index-define_002dwindows_002dtype-3123"></a></var><br>
&mdash; special form: <b>define-similar-windows-type</b><var> name model </var>[<var>check </var>[<var>convert </var>[<var>return </var>[<var>revert</var>]]]]<var><a name="index-define_002dsimilar_002dwindows_002dtype-3124"></a></var><br>
<blockquote><p><a name="index-defining-foreign-types-3125"></a>Both forms define a windows type. 
The first form defines a type in terms of its aspects as described
above. 
The second defines the type as being like another type, except for
certain aspects, which are redefined. 
<var>Name</var> is the name of the type. 
<var>Model</var> is the name of a type. 
<var>Check</var>, <var>convert</var>, <var>return</var> and <var>revert</var> are
procedures or the value <code>#f</code>. 
A <code>#f</code> means use the default value, which in the second form means
use the definition provided for <var>model</var>. 
The defaults are

          <dl>
<dt><var>check</var><dd><code>(lambda (x) #t)</code>, i.e. unchecked. 
<br><dt><var>convert</var><dd><code>(lambda (x) x)</code>, i.e. no translation performed. 
<br><dt><var>return</var><dd><code>(lambda (x) x)</code>, i.e. no translation performed. 
<br><dt><var>revert</var><dd><code>(lambda (x y) unspecific)</code>, i.e. no update performed
</dl>

        <p>The <code>unchecked</code> windows type (see below) is defined as:

     <pre class="example">          (define-windows-type unchecked #f #f #f #f)
</pre>
        <p>Windows types are <em>not</em> first class values, so they cannot be
stored in variables or defined using <code>define</code>:

     <pre class="example">          (define my-type unchecked)            error--&gt;  Unbound variable
          (define-similar-windows-type my-type unchecked)
                                                <span class="roman">;; the correct way</span>
</pre>
        <p>Scheme characters must be converted to integers.  This is accomplished
as follows:

     <pre class="example">          (define-windows-type char
             char?          <span class="roman">; check</span>
             char-&gt;integer  <span class="roman">; convert</span>
             integer-&gt;char  <span class="roman">; convert return value</span>
             #f             <span class="roman">; cannot be passed by reference</span>
          )
</pre>
        </blockquote></div>

<div class="defun">
&mdash; windows type: <b>unchecked</b><var><a name="index-unchecked-3126"></a></var><br>
<blockquote><p>The type which is not checked and undergoes only the basic conversion
from a Scheme integer to a C integer or from a Scheme string to a C
pointer to the first byte of the string. 
Returned <code>unchecked</code> values are returned as integers. 
</p></blockquote></div>

<div class="defun">
&mdash; windows type: <b>bool</b><var><a name="index-bool-3127"></a></var><br>
<blockquote><p>Scheme booleans are analogous to C integers <code>0</code> and <code>1</code>. 
Windows type <code>bool</code> have been defined as:

     <pre class="example">          (define-windows-type bool
             boolean?
             (lambda (x) (if x 1 0))
             (lambda (x) (if (eq? x 0) #f #t))
             #f)
</pre>
        </blockquote></div>

<div class="defun">
&mdash; windows type: <b>char</b><var><a name="index-char-3128"></a></var><br>
<blockquote><p>Scheme characters are converted into C objects of type <code>char</code>,
which are indistinguishable from small integers. 
</p></blockquote></div>

<div class="defun">
&mdash; windows type: <b>int</b><var><a name="index-int-3129"></a></var><br>
&mdash; windows type: <b>uint</b><var><a name="index-uint-3130"></a></var><br>
&mdash; windows type: <b>long</b><var><a name="index-long-3131"></a></var><br>
&mdash; windows type: <b>ulong</b><var><a name="index-ulong-3132"></a></var><br>
&mdash; windows type: <b>short</b><var><a name="index-short-3133"></a></var><br>
&mdash; windows type: <b>ushort</b><var><a name="index-ushort-3134"></a></var><br>
&mdash; windows type: <b>word</b><var><a name="index-word-3135"></a></var><br>
&mdash; windows type: <b>byte</b><var><a name="index-byte-3136"></a></var><br>
<blockquote><p>Various integer types that are passed without conversion. 
</p></blockquote></div>

<div class="defun">
&mdash; windows type: <b>string</b><var><a name="index-string-3137"></a></var><br>
<blockquote><p>A string that is passed as a C pointer of type <code>char*</code> to the first
character in the string. 
</p></blockquote></div>

<div class="defun">
&mdash; windows type: <b>char*</b><var><a name="index-char_002a-3138"></a></var><br>
<blockquote><p>A string or <code>#f</code>.  The string is passed as a pointer to characters. 
The string is correctly null-terminated.  <code>#f</code> is passed as the null
pointer.  This is an example where there is a more complex mapping
between C objects and Scheme objects.  C's <code>char*</code> type is
represented as one of two Scheme types depending on its value.  This
allows us us to distinguish between the C string (pointer) that points
to the empty sequence of characters and the null pointer (which doesnt
point anywhere). 
</p></blockquote></div>

<div class="defun">
&mdash; windows type: <b>handle</b><var><a name="index-handle-3139"></a></var><br>
&mdash; windows type: <b>hbitmap</b><var><a name="index-hbitmap-3140"></a></var><br>
&mdash; windows type: <b>hbrush</b><var><a name="index-hbrush-3141"></a></var><br>
&mdash; windows type: <b>hcursor</b><var><a name="index-hcursor-3142"></a></var><br>
&mdash; windows type: <b>hdc</b><var><a name="index-hdc-3143"></a></var><br>
&mdash; windows type: <b>hicon</b><var><a name="index-hicon-3144"></a></var><br>
&mdash; windows type: <b>hinstance</b><var><a name="index-hinstance-3145"></a></var><br>
&mdash; windows type: <b>hmenu</b><var><a name="index-hmenu-3146"></a></var><br>
&mdash; windows type: <b>hpalette</b><var><a name="index-hpalette-3147"></a></var><br>
&mdash; windows type: <b>hpen</b><var><a name="index-hpen-3148"></a></var><br>
&mdash; windows type: <b>hrgn</b><var><a name="index-hrgn-3149"></a></var><br>
&mdash; windows type: <b>hwnd</b><var><a name="index-hwnd-3150"></a></var><br>
<blockquote><p>Various kinds of Win32 handle.  These names correspond to the same, but
all uppercase, names in the Windows C language header files.  Win32 API
calls are the source of values of this type and the values are
meaningless except as arguments to other Win32 API calls.  Currently
these values are represented as integers but we expect that Win32
handles will in future be represented by allocated Scheme objects
(e.g. records) that will allow predicates (e.g. <code>hmenu?</code>) and
sensible interlocking with the garbage collector to free the programmer
of the current tedious allocation and deallocation of handles. 
</p></blockquote></div>

<div class="defun">
&mdash; windows type: <b>resource-id</b><var><a name="index-resource_002did-3151"></a></var><br>
<blockquote><p>A Windows resource identifier is either a small integer or a string. 
In C, this distinction is possible because pointers look like
larger integers, so a machine word representing a small integer can be
distinguished from a machine word that is a pointer to the text of the
name of the resource. 
</p></blockquote></div>

   </body></html>

