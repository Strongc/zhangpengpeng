<html lang="en">
<head>
<title>Red-Black Trees - MIT/GNU Scheme 9.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Associations.html#Associations" title="Associations">
<link rel="prev" href="Object-Hashing.html#Object-Hashing" title="Object Hashing">
<link rel="next" href="Weight_002dBalanced-Trees.html#Weight_002dBalanced-Trees" title="Weight-Balanced Trees">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents MIT/GNU Scheme 9.0.1.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Red-Black-Trees"></a>
<a name="Red_002dBlack-Trees"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Weight_002dBalanced-Trees.html#Weight_002dBalanced-Trees">Weight-Balanced Trees</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Object-Hashing.html#Object-Hashing">Object Hashing</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Associations.html#Associations">Associations</a>
<hr>
</div>

<h3 class="section">11.6 Red-Black Trees</h3>

<p><a name="index-trees_002c-balanced-binary-1715"></a><a name="index-balanced-binary-trees-1716"></a><a name="index-binary-trees-1717"></a><a name="index-red_002dblack-binary-trees-1718"></a>Balanced binary trees are a useful data structure for maintaining large
sets of associations whose keys are ordered.  While most applications
involving large association sets should use hash tables, some
applications can benefit from the use of binary trees.  Binary trees
have two advantages over hash tables:

     <ul>
<li>The contents of a binary tree can be converted to an alist, sorted by
key, in time proportional to the number of associations in the
tree.  A hash table can be converted into an unsorted alist in linear
time; sorting it requires additional time.

     <li>Two binary trees can be compared for equality in linear time.  Hash
tables, on the other hand, cannot be compared at all; they must be
converted to alists before comparison can be done, and alist comparison
is quadratic unless the alists are sorted. 
</ul>

   <p>MIT/GNU Scheme provides an implementation of <dfn>red-black</dfn> trees.  The
red-black tree-balancing algorithm provides generally good performance
because it doesn't try to keep the tree very closely balanced.  At any
given node in the tree, one side of the node can be twice as high as the
other in the worst case.  With typical data the tree will remain fairly
well balanced anyway.

   <p>A red-black tree takes space that is proportional to the number of
associations in the tree.  For the current implementation, the constant
of proportionality is eight words per association.

   <p>Red-black trees hold their keys <dfn>strongly</dfn>.  In other words, if a
red-black tree contains an association for a given key, that key cannot
be reclaimed by the garbage collector.

   <p><a name="index-run_002dtime_002dloadable-option-1719"></a><a name="index-option_002c-run_002dtime_002dloadable-1720"></a>The red-black tree implementation is a run-time-loadable option.  To use
red-black trees, execute

<pre class="example">     (load-option 'rb-tree)
</pre>
   <p><a name="index-load_002doption-1721"></a>
once before calling any of the procedures defined here.

<div class="defun">
&mdash; procedure: <b>make-rb-tree</b><var> key=? key&lt;?<a name="index-make_002drb_002dtree-1722"></a></var><br>
<blockquote><p>This procedure creates and returns a newly allocated red-black tree. 
The tree contains no associations.  <var>Key=?</var> and <var>key&lt;?</var> are
predicates that compare two keys and determine whether they are equal to
or less than one another, respectively.  For any two keys, at most one
of these predicates is true. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>rb-tree?</b><var> object<a name="index-rb_002dtree_003f-1723"></a></var><br>
<blockquote><p>Returns <code>#t</code> if <var>object</var> is a red-black tree, otherwise
returns <code>#f</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>rb-tree/insert!</b><var> rb-tree key datum<a name="index-rb_002dtree_002finsert_0021-1724"></a></var><br>
<blockquote><p>Associates <var>datum</var> with <var>key</var> in <var>rb-tree</var> and returns an
unspecified value.  If <var>rb-tree</var> already has an association for
<var>key</var>, that association is replaced.  The average and worst-case
times required by this operation are proportional to the logarithm of
the number of assocations in <var>rb-tree</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>rb-tree/lookup</b><var> rb-tree key default<a name="index-rb_002dtree_002flookup-1725"></a></var><br>
<blockquote><p>Returns the datum associated with <var>key</var> in <var>rb-tree</var>.  If
<var>rb-tree</var> doesn't contain an association for <var>key</var>,
<var>default</var> is returned.  The average and worst-case times required by
this operation are proportional to the logarithm of the number of
assocations in <var>rb-tree</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>rb-tree/delete!</b><var> rb-tree key<a name="index-rb_002dtree_002fdelete_0021-1726"></a></var><br>
<blockquote><p>If <var>rb-tree</var> contains an association for <var>key</var>, removes it. 
Returns an unspecified value.  The average and worst-case times required
by this operation are proportional to the logarithm of the number of
assocations in <var>rb-tree</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>rb-tree-&gt;alist</b><var> rb-tree<a name="index-rb_002dtree_002d_003ealist-1727"></a></var><br>
<blockquote><p>Returns the contents of <var>rb-tree</var> as a newly allocated alist.  Each
element of the alist is a pair <code>(</code><var>key</var><code> . </code><var>datum</var><code>)</code> where
<var>key</var> is one of the keys of <var>rb-tree</var>, and <var>datum</var> is its
associated datum.  The alist is sorted by key according to the
<var>key&lt;?</var> argument used to construct <var>rb-tree</var>.  The
time required by this operation is proportional to the
number of associations in the tree. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>rb-tree/key-list</b><var> rb-tree<a name="index-rb_002dtree_002fkey_002dlist-1728"></a></var><br>
<blockquote><p>Returns a newly allocated list of the keys in <var>rb-tree</var>.  The list
is sorted by key according to the <var>key&lt;?</var> argument used to construct
<var>rb-tree</var>.  The time required by this
operation is proportional to the number of associations in the tree. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>rb-tree/datum-list</b><var> rb-tree<a name="index-rb_002dtree_002fdatum_002dlist-1729"></a></var><br>
<blockquote><p>Returns a newly allocated list of the datums in <var>rb-tree</var>.  Each
element of the list corresponds to one of the associations in
<var>rb-tree</var>, so if the tree contains multiple associations with the
same datum, so will this list.  The list is sorted by the keys of the
associations, even though they do not appear in the result.  The time required by this operation is proportional to the
number of associations in the tree.

        <p>This procedure is equivalent to:

     <pre class="example">          (lambda (rb-tree) (map cdr (rb-tree-&gt;alist rb-tree)))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>rb-tree/equal?</b><var> rb-tree-1 rb-tree-2 datum=?<a name="index-rb_002dtree_002fequal_003f-1730"></a></var><br>
<blockquote><p>Compares <var>rb-tree-1</var> and <var>rb-tree-2</var> for equality, returning
<code>#t</code> iff they are equal and <code>#f</code> otherwise.  The trees must
have been constructed with the same equality and order predicates (same
in the sense of <code>eq?</code>).  The keys of the trees are compared using
the <var>key=?</var> predicate used to build the trees, while the datums of
the trees are compared using the equivalence predicate <var>datum=?</var>. 
The worst-case time required by this operation is proportional to the
number of associations in the tree. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>rb-tree/empty?</b><var> rb-tree<a name="index-rb_002dtree_002fempty_003f-1731"></a></var><br>
<blockquote><p>Returns <code>#t</code> iff <var>rb-tree</var> contains no associations.  Otherwise
returns <code>#f</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>rb-tree/size</b><var> rb-tree<a name="index-rb_002dtree_002fsize-1732"></a></var><br>
<blockquote><p>Returns the number of associations in <var>rb-tree</var>, an exact
non-negative integer.  The average and worst-case times required by this
operation are proportional to the number of associations in the tree. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>rb-tree/height</b><var> rb-tree<a name="index-rb_002dtree_002fheight-1733"></a></var><br>
<blockquote><p>Returns the height of <var>rb-tree</var>, an exact non-negative integer. 
This is the length of the longest path from a leaf of the tree to the
root.  The average and worst-case times required by this operation are
proportional to the number of associations in the tree.

        <p>The returned value satisfies the following:

     <pre class="example">          (lambda (rb-tree)
            (let ((size (rb-tree/size rb-tree))
                  (lg (lambda (x) (/ (log x) (log 2)))))
              (&lt;= (lg size)
                  (rb-tree/height rb-tree)
                  (* 2 (lg (+ size 1))))))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>rb-tree/copy</b><var> rb-tree<a name="index-rb_002dtree_002fcopy-1734"></a></var><br>
<blockquote><p>Returns a newly allocated copy of <var>rb-tree</var>.  The copy is identical
to <var>rb-tree</var> in all respects, except that changes to <var>rb-tree</var>
do not affect the copy, and vice versa.  The time required by this
operation is proportional to the number of associations in the tree. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>alist-&gt;rb-tree</b><var> alist key=? key&lt;?<a name="index-alist_002d_003erb_002dtree-1735"></a></var><br>
<blockquote><p>Returns a newly allocated red-black tree that contains the same
associations as <var>alist</var>.  This procedure is equivalent to:

     <pre class="example">          (lambda (alist key=? key&lt;?)
            (let ((tree (make-rb-tree key=? key&lt;?)))
              (for-each (lambda (association)
                          (rb-tree/insert! tree
                                           (car association)
                                           (cdr association)))
                        alist)
              tree))
</pre>
        </blockquote></div>

   <p>The following operations provide access to the smallest and largest
members in a red/black tree.  They are useful for implementing priority
queues.

<div class="defun">
&mdash; procedure: <b>rb-tree/min</b><var> rb-tree default<a name="index-rb_002dtree_002fmin-1736"></a></var><br>
<blockquote><p>Returns the smallest key in <var>rb-tree</var>, or <var>default</var> if the tree
is empty. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>rb-tree/min-datum</b><var> rb-tree default<a name="index-rb_002dtree_002fmin_002ddatum-1737"></a></var><br>
<blockquote><p>Returns the datum associated with the smallest key in <var>rb-tree</var>, or
<var>default</var> if the tree is empty. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>rb-tree/min-pair</b><var> rb-tree<a name="index-rb_002dtree_002fmin_002dpair-1738"></a></var><br>
<blockquote><p>Finds the smallest key in <var>rb-tree</var> and returns a pair containing
that key and its associated datum.  If the tree is empty, returns
<code>#f</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>rb-tree/max</b><var> rb-tree default<a name="index-rb_002dtree_002fmax-1739"></a></var><br>
<blockquote><p>Returns the largest key in <var>rb-tree</var>, or <var>default</var> if the tree
is empty. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>rb-tree/max-datum</b><var> rb-tree default<a name="index-rb_002dtree_002fmax_002ddatum-1740"></a></var><br>
<blockquote><p>Returns the datum associated with the largest key in <var>rb-tree</var>, or
<var>default</var> if the tree is empty. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>rb-tree/max-pair</b><var> rb-tree<a name="index-rb_002dtree_002fmax_002dpair-1741"></a></var><br>
<blockquote><p>Finds the largest key in <var>rb-tree</var> and returns a pair containing
that key and its associated datum.  If the tree is empty, returns
<code>#f</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>rb-tree/delete-min!</b><var> rb-tree default<a name="index-rb_002dtree_002fdelete_002dmin_0021-1742"></a></var><br>
&mdash; procedure: <b>rb-tree/delete-min-datum!</b><var> rb-tree default<a name="index-rb_002dtree_002fdelete_002dmin_002ddatum_0021-1743"></a></var><br>
&mdash; procedure: <b>rb-tree/delete-min-pair!</b><var> rb-tree<a name="index-rb_002dtree_002fdelete_002dmin_002dpair_0021-1744"></a></var><br>
&mdash; procedure: <b>rb-tree/delete-max!</b><var> rb-tree default<a name="index-rb_002dtree_002fdelete_002dmax_0021-1745"></a></var><br>
&mdash; procedure: <b>rb-tree/delete-max-datum!</b><var> rb-tree default<a name="index-rb_002dtree_002fdelete_002dmax_002ddatum_0021-1746"></a></var><br>
&mdash; procedure: <b>rb-tree/delete-max-pair!</b><var> rb-tree<a name="index-rb_002dtree_002fdelete_002dmax_002dpair_0021-1747"></a></var><br>
<blockquote><p>These operations are exactly like the accessors above, in that they
return information associated with the smallest or largest key, except
that they simultaneously delete that key. 
</p></blockquote></div>

   </body></html>

