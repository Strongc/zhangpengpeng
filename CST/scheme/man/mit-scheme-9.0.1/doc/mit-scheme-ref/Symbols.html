<html lang="en">
<head>
<title>Symbols - MIT/GNU Scheme 9.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Miscellaneous-Datatypes.html#Miscellaneous-Datatypes" title="Miscellaneous Datatypes">
<link rel="prev" href="Booleans.html#Booleans" title="Booleans">
<link rel="next" href="Cells.html#Cells" title="Cells">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents MIT/GNU Scheme 9.0.1.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Symbols"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Cells.html#Cells">Cells</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Booleans.html#Booleans">Booleans</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Miscellaneous-Datatypes.html#Miscellaneous-Datatypes">Miscellaneous Datatypes</a>
<hr>
</div>

<h3 class="section">10.2 Symbols</h3>

<p><a name="index-symbol-_0028defn_0029-1458"></a><a name="index-interned-symbol-_0028defn_0029-1459"></a><a name="index-uninterned-symbol-_0028defn_0029-1460"></a><a name="index-property-list_002c-of-symbol-1461"></a><a name="index-disembodied-property-list-1462"></a><a name="index-read-1463"></a>MIT/GNU Scheme provides two types of symbols: <dfn>interned</dfn> and
<dfn>uninterned</dfn>.  Interned symbols are far more common than uninterned
symbols, and there are more ways to create them.  Interned symbols have
an external representation that is recognized by the procedure
<code>read</code>; uninterned symbols do not.<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>

   <p><a name="index-string_003d_003f-1464"></a><a name="index-eq_003f-1465"></a>Interned symbols have an extremely useful property: any two interned
symbols whose names are the same, in the sense of <code>string=?</code>, are
the same object (i.e. they are <code>eq?</code> to one another).  The term
<dfn>interned</dfn> refers to the process of <dfn>interning</dfn> by which this is
accomplished.  Uninterned symbols do not share this property.

   <p><a name="index-case_002c-of-interned-symbol-1466"></a><a name="index-alphabetic-case_002c-of-interned-symbol-1467"></a><a name="index-write-1468"></a>The names of interned symbols are not distinguished by their alphabetic
case.  Because of this, MIT/GNU Scheme converts all alphabetic
characters in the name of an interned symbol to a specific case (lower
case) when the symbol is created.  When the name of an interned symbol
is referenced (using <code>symbol-&gt;string</code>) or written (using
<code>write</code>) it appears in this case.  It is a bad idea to depend on
the name being lower case.  In fact, it is preferable to take this one
step further: don't depend on the name of a symbol being in a uniform
case.

   <p><a name="index-external-representation_002c-for-symbol-1469"></a><a name="index-read-1470"></a><a name="index-write-1471"></a>The rules for writing an interned symbol are the same as the rules for
writing an identifier (see <a href="Identifiers.html#Identifiers">Identifiers</a>).  Any interned symbol that
has been returned as part of a literal expression, or read using the
<code>read</code> procedure and subsequently written out using the
<code>write</code> procedure, will read back in as the identical symbol (in
the sense of <code>eq?</code>).

   <p>Usually it is also true that reading in an interned symbol that was
previously written out produces the same symbol.  An exception are
symbols created by the procedures <code>string-&gt;symbol</code> and
<code>intern</code>; they can create symbols for which this write/read
invariance may not hold because the symbols' names contain special
characters or letters in the non-standard case.<a rel="footnote" href="#fn-2" name="fnd-2"><sup>2</sup></a>

   <p><a name="index-read-1472"></a>The external representation for uninterned symbols is special, to
distinguish them from interned symbols and prevent them from being
recognized by the <code>read</code> procedure:

<pre class="example">     (string-&gt;uninterned-symbol "foo")
          &rArr;  #[uninterned-symbol 30 foo]
</pre>
   <p>In this section, the procedures that return symbols as values will
either always return interned symbols, or always return uninterned
symbols.  The procedures that accept symbols as arguments will always
accept either interned or uninterned symbols, and do not distinguish the
two.

<div class="defun">
&mdash; procedure: <b>symbol?</b><var> object<a name="index-symbol_003f-1473"></a></var><br>
<blockquote><p><a name="index-type-predicate_002c-for-symbol-1474"></a>Returns <code>#t</code> if <var>object</var> is a symbol, otherwise returns
<code>#f</code>.

     <pre class="example">          (symbol? 'foo)                                  &rArr;  #t
          (symbol? (car '(a b)))                          &rArr;  #t
          (symbol? "bar")                                 &rArr;  #f
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>symbol-&gt;string</b><var> symbol<a name="index-symbol_002d_003estring-1475"></a></var><br>
<blockquote><p><a name="index-name_002c-of-symbol-1476"></a><a name="index-print-name_002c-of-symbol-1477"></a><a name="index-string_003d_003f-1478"></a><a name="index-string_002dset_0021-1479"></a>Returns the name of <var>symbol</var> as a string.  If <var>symbol</var> was
returned by <code>string-&gt;symbol</code>, the value of this procedure will be
identical (in the sense of <code>string=?</code>) to the string that was
passed to <code>string-&gt;symbol</code>.  It is an error to apply mutation
procedures such as <code>string-set!</code> to strings returned by this
procedure.

     <pre class="example">          (symbol-&gt;string 'flying-fish)           &rArr;  "flying-fish"
          (symbol-&gt;string 'Martin)                &rArr;  "martin"
          (symbol-&gt;string (string-&gt;symbol "Malvina"))
                                                  &rArr;  "Malvina"
</pre>
        <p>Note that two distinct uninterned symbols can have the same name. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>intern</b><var> string<a name="index-intern-1480"></a></var><br>
<blockquote><p><a name="index-interning_002c-of-symbols-1481"></a><a name="index-construction_002c-of-symbols-1482"></a>Returns the interned symbol whose name is <var>string</var>.  Converts
<var>string</var> to the standard alphabetic case before generating the
symbol.  This is the preferred way to create interned symbols, as it
guarantees the following independent of which case the implementation
uses for symbols' names:

     <pre class="example">          (eq? 'bitBlt (intern "bitBlt")) &rArr;     #t
</pre>
        <p>The user should take care that <var>string</var> obeys the rules for
identifiers (see <a href="Identifiers.html#Identifiers">Identifiers</a>), otherwise the resulting symbol cannot
be read as itself. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>intern-soft</b><var> string<a name="index-intern_002dsoft-1483"></a></var><br>
<blockquote><p>Returns the interned symbol whose name is <var>string</var>.  Converts
<var>string</var> to the standard alphabetic case before generating the
symbol.  If no such interned symbol exists, returns <code>#f</code>.

        <p>This is exactly like <code>intern</code>, except that it will not create an
interned symbol, but only returns symbols that already exist. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>string-&gt;symbol</b><var> string<a name="index-string_002d_003esymbol-1484"></a></var><br>
<blockquote><p><a name="index-string_002c-interning-as-symbol-1485"></a>Returns the interned symbol whose name is <var>string</var>.  Although you
can use this procedure to create symbols with names containing special
characters or lowercase letters, it's usually a bad idea to create such
symbols because they cannot be read as themselves.  See
<code>symbol-&gt;string</code>.

     <pre class="example">          (eq? 'mISSISSIppi 'mississippi)         &rArr;  #t
          (string-&gt;symbol "mISSISSIppi")
               &rArr;  <span class="roman">the symbol with the name</span> "mISSISSIppi"
          (eq? 'bitBlt (string-&gt;symbol "bitBlt")) &rArr;  #f
          (eq? 'JollyWog
                (string-&gt;symbol
                  (symbol-&gt;string 'JollyWog)))    &rArr;  #t
          (string=? "K. Harper, M.D."
                     (symbol-&gt;string
                       (string-&gt;symbol
                         "K. Harper, M.D.")))     &rArr;  #t
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>string-&gt;uninterned-symbol</b><var> string<a name="index-string_002d_003euninterned_002dsymbol-1486"></a></var><br>
<blockquote><p>Returns a newly allocated uninterned symbol whose name is <var>string</var>. 
It is unimportant what case or characters are used in
<var>string</var>.

        <p>Note: this is the fastest way to make a symbol. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>generate-uninterned-symbol</b> [<var>object</var>]<var><a name="index-generate_002duninterned_002dsymbol-1487"></a></var><br>
<blockquote><p><a name="index-gensym-_0028see-uninterned-symbol_0029-1488"></a><a name="index-eq_003f-1489"></a>Returns a newly allocated uninterned symbol that is guaranteed to be
different from any other object.  The symbol's name consists of a prefix
string followed by the (exact non-negative integer) value of an internal
counter.  The counter is initially zero, and is incremented after each
call to this procedure.

        <p>The optional argument <var>object</var> is used to control how the symbol is
generated.  It may take one of the following values:

          <ul>
<li>If <var>object</var> is omitted or <code>#f</code>, the prefix is <code>"G"</code>.

          <li>If <var>object</var> is an exact non-negative integer, the internal counter
is set to that integer prior to generating the result.

          <li>If <var>object</var> is a string, it is used as the prefix.

          <li>If <var>object</var> is a symbol, its name is used as the prefix. 
</ul>

     <pre class="example">          (generate-uninterned-symbol)
               &rArr;  #[uninterned-symbol 31 G0]
          (generate-uninterned-symbol)
               &rArr;  #[uninterned-symbol 32 G1]
          (generate-uninterned-symbol 'this)
               &rArr;  #[uninterned-symbol 33 this2]
          (generate-uninterned-symbol)
               &rArr;  #[uninterned-symbol 34 G3]
          (generate-uninterned-symbol 100)
               &rArr;  #[uninterned-symbol 35 G100]
          (generate-uninterned-symbol)
               &rArr;  #[uninterned-symbol 36 G101]
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>symbol-append</b><var> symbol <small class="dots">...</small><a name="index-symbol_002dappend-1490"></a></var><br>
<blockquote><p><a name="index-appending_002c-of-symbols-1491"></a><a name="index-pasting_002c-of-symbols-1492"></a>Returns the interned symbol whose name is formed by concatenating the
names of the given symbols.  This procedure preserves the case of the
names of its arguments, so if one or more of the arguments' names has
non-standard case, the result will also have non-standard case.

     <pre class="example">          (symbol-append 'foo- 'bar)              &rArr;  foo-bar
          <span class="roman">;; the arguments may be uninterned:</span>
          (symbol-append 'foo- (string-&gt;uninterned-symbol "baz"))
                                                  &rArr;  foo-baz
          <span class="roman">;; the result has the same case as the arguments:</span>
          (symbol-append 'foo- (string-&gt;symbol "BAZ"))    &rArr;  foo-BAZ
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>symbol-hash</b><var> symbol<a name="index-symbol_002dhash-1493"></a></var><br>
<blockquote><p><a name="index-hashing_002c-of-symbol-1494"></a><a name="index-string_002dhash-1495"></a>Returns a hash number for <var>symbol</var>, which is computed by calling
<code>string-hash</code> on <var>symbol</var>'s name.  The hash number is an exact
non-negative integer. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>symbol-hash-mod</b><var> symbol modulus<a name="index-symbol_002dhash_002dmod-1496"></a></var><br>
<blockquote><p><var>Modulus</var> must be an exact positive integer.  Equivalent to

     <pre class="example">          (modulo (symbol-hash <var>symbol</var>) <var>modulus</var>)
</pre>
        <p>This procedure is provided for convenience in constructing hash tables. 
However, it is normally preferable to use
<code>make-strong-eq-hash-table</code> to build hash tables keyed by symbols,
because <code>eq?</code> hash tables are much faster. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>symbol&lt;?</b><var> symbol1 symbol2<a name="index-symbol_003c_003f-1497"></a></var><br>
<blockquote><p>This procedure computes a total order on symbols.  It is equivalent to

     <pre class="example">          (string&lt;? (symbol-&gt;string <var>symbol1</var>)
                    (symbol-&gt;string <var>symbol2</var>))
</pre>
        </blockquote></div>

   <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> In older dialects of
Lisp, uninterned symbols were fairly important.  This was true because
symbols were complicated data structures: in addition to having value
cells (and sometimes, function cells), these structures contained
<dfn>property lists</dfn>.  Because of this, uninterned symbols were often
used merely for their property lists &mdash; sometimes an uninterned symbol
used this way was referred to as a <dfn>disembodied property list</dfn>.  In
MIT/GNU Scheme, symbols do not have property lists, or any other components
besides their names.  There is a different data structure similar to
disembodied property lists: one-dimensional tables (see <a href="1D-Tables.html#g_t1D-Tables">1D Tables</a>). 
For these reasons, uninterned symbols are not very useful in MIT/GNU Scheme. 
In fact, their primary purpose is to simplify the generation of unique
variable names in programs that generate Scheme code.</p>

   <p class="footnote"><small>[<a name="fn-2" href="#fnd-2">2</a>]</small> MIT/GNU Scheme
reserves a specific set of interned symbols for its own use.  If you use
these reserved symbols it is possible that you could break specific
pieces of software that depend on them.  The reserved symbols all have
names beginning with the characters &lsquo;<samp><span class="samp">#[</span></samp>&rsquo; and ending with the
character &lsquo;<samp><span class="samp">]</span></samp>&rsquo;; thus none of these symbols can be read by the
procedure <code>read</code> and hence are not likely to be used by accident. 
For example, <code>(intern "#[unnamed-procedure]")</code> produces a reserved
symbol.</p>

   <hr></div>

   </body></html>

