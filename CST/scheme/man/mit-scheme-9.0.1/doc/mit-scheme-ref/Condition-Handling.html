<html lang="en">
<head>
<title>Condition Handling - MIT/GNU Scheme 9.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Error-System.html#Error-System" title="Error System">
<link rel="prev" href="Error-Messages.html#Error-Messages" title="Error Messages">
<link rel="next" href="Restarts.html#Restarts" title="Restarts">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents MIT/GNU Scheme 9.0.1.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Condition-Handling"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Restarts.html#Restarts">Restarts</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Error-Messages.html#Error-Messages">Error Messages</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Error-System.html#Error-System">Error System</a>
<hr>
</div>

<h3 class="section">16.3 Condition Handling</h3>

<p><a name="index-handler_002c-condition-_0028defn_0029-2800"></a><a name="index-condition-handler-_0028defn_0029-2801"></a><a name="index-bind_002dcondition_002dhandler-2802"></a><a name="index-bind_002ddefault_002dcondition_002dhandler-2803"></a>The occurrence of a condition is signalled using
<code>signal-condition</code>.  <code>signal-condition</code> attempts to locate and
invoke a <dfn>condition handler</dfn> that is prepared to deal with the type
of condition that has occurred.  A condition handler is a procedure of
one parameter, the condition that is being signalled.  A procedure is
installed as a condition handler by calling
<code>bind-condition-handler</code> (to establish a handler that is in effect
only while a particular thunk is executing) or
<code>bind-default-condition-handler</code> (to establish a handler that is in
effect permanently).  As implied by the name, handlers created by
<code>bind-default-condition-handler</code> are invoked only after all other
applicable handlers have been invoked.

   <p>A <var>handler</var> may process a signal in any way it deems appropriate,
but the common patterns are:

     <dl>
<dt>Ignore the condition.<dd>By returning from the handler in the usual manner.

     <br><dt>Handle the condition.<dd>By doing some processing and then invoking a restart (or, less
preferably, a continuation) that was established at some point prior to
the call to <code>signal-condition</code>.

     <br><dt>Resignal a condition.<dd>By doing some processing and calling <code>signal-condition</code> with either
the same condition or a newly created one.  In order to support this,
<code>signal-condition</code> runs <var>handler</var> in such a way that a
subsequent call to <code>signal-condition</code> sees only the handlers that
were established prior to this one. 
</dl>

   <p><a name="index-REP-loop-2804"></a><a name="index-break_002don_002dsignals-2805"></a>As an aid to debugging condition handlers, Scheme maintains a set of
condition types that will cause an interactive breakpoint to occur prior
to normal condition signalling.  That is, <code>signal-condition</code>
creates a new <span class="sc">repl</span> prior to its normal operation when its argument
is a condition that is a specialization of any of these types.  The
procedure <code>break-on-signals</code> establishes this set of condition
types.

<div class="defun">
&mdash; procedure: <b>ignore-errors</b><var> thunk<a name="index-ignore_002derrors-2806"></a></var><br>
<blockquote><p><a name="index-error-2807"></a><a name="index-condition_002dtype_003aerror-2808"></a>Executes <var>thunk</var> with a condition handler that intercepts the
signalling of any specialization of <code>condition-type:error</code>
(including those produced by calls to <code>error</code>) and immediately
terminates the execution of <var>thunk</var> and returns from the call to
<code>ignore-errors</code> with the signalled condition as its value.  If
<var>thunk</var> returns normally, its value is returned from
<code>ignore-errors</code>.

        <p>Notice that <code>ignore-errors</code> does not &ldquo;turn off signalling&rdquo; or
condition handling.  Condition handling takes place in the normal manner
but conditions specialized from <code>condition-type:error</code> are trapped
rather than propogated as they would be by default. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>bind-condition-handler</b><var> condition-types handler thunk<a name="index-bind_002dcondition_002dhandler-2809"></a></var><br>
<blockquote><p><a name="index-signal_002dcondition-2810"></a>Invokes <var>thunk</var> after adding <var>handler</var> as a condition handler
for the conditions specified by <var>condition-types</var>. 
<var>Condition-types</var> must be a list of condition types; signalling a
condition whose type is a specialization of any of these types will
cause the <var>handler</var> to be invoked.  See <code>signal-condition</code> for
a description of the mechanism used to invoke handlers.

        <p>By special extension, if <var>condition-types</var> is the empty list then
the <var>handler</var> is called for all conditions. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>bind-default-condition-handler</b><var> condition-types handler<a name="index-bind_002ddefault_002dcondition_002dhandler-2811"></a></var><br>
<blockquote><p><a name="index-signal_002dcondition-2812"></a>Installs <var>handler</var> as a (permanent) condition handler for the
conditions specified by <var>condition-types</var>.  <var>Condition-types</var>
must be a list of condition types; signalling a condition whose type is
a specialization of any of these types will cause the <var>handler</var> to
be invoked.  See <code>signal-condition</code> for a description of the
mechanism used to invoke handlers.

        <p>By special extension, if <var>condition-types</var> is the empty list then
the <var>handler</var> is called for all conditions. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>break-on-signals</b><var> condition-types<a name="index-break_002don_002dsignals-2813"></a></var><br>
<blockquote><p><a name="index-signal_002dcondition-2814"></a><a name="index-REP-loop-2815"></a>Arranges for <code>signal-condition</code> to create an interactive <span class="sc">repl</span>
before it signals a condition that is a specialization of any of the
types in the list of <var>condition-types</var>.  This can be extremely
helpful when trying to debug code that uses custom condition handlers. 
In order to create a <span class="sc">repl</span> when <em>any</em> condition type is
signalled it is best to actually put a breakpoint on entry to
<code>signal-condition</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>standard-error-handler</b><var> condition<a name="index-standard_002derror_002dhandler-2816"></a></var><br>
<blockquote><p><a name="index-error-2817"></a><a name="index-ignore_002derror-2818"></a><a name="index-standard_002derror_002dhook-2819"></a><a name="index-REP-loop-2820"></a>Called internally by <code>error</code> after it calls
<code>signal-condition</code>.  Normally creates creates a new <span class="sc">repl</span> with
the prompt <code>"error&gt;"</code> (but see <code>standard-error-hook</code>).  In
order to simulate the effect of calling <code>error</code>, code may call
<code>signal-condition</code> directly and then call
<code>standard-error-handler</code> if <code>signal-condition</code> returns. 
</p></blockquote></div>

<div class="defun">
&mdash; variable: <b>standard-error-hook</b><var><a name="index-standard_002derror_002dhook-2821"></a></var><br>
<blockquote><p><a name="index-standard_002derror_002dhandler-2822"></a><a name="index-fluid-binding-2823"></a><a name="index-dynamic-binding-2824"></a><a name="index-REP-loop-2825"></a>This variable controls the behavior of the procedure
<code>standard-error-handler</code>, and hence <code>error</code>.  It is intended
to be bound with <code>fluid-let</code> and is normally <code>#f</code>.  It may be
changed to a procedure of one argument and will then be invoked (with
<code>standard-error-hook</code> rebound to <code>#f</code>) by
<code>standard-error-handler</code> just prior to starting the error
<span class="sc">repl</span>.  It is passed one argument, the condition being signalled. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>standard-warning-handler</b><var> condition<a name="index-standard_002dwarning_002dhandler-2826"></a></var><br>
<blockquote><p><a name="index-standard_002dwarning_002dhook-2827"></a><a name="index-signal_002dcondition-2828"></a><a name="index-notification_002doutput_002dport-2829"></a><a name="index-write_002dcondition_002dreport-2830"></a>This is the procedure called internally by <code>warn</code> after it calls
<code>signal-condition</code>.  The normal behavior of
<code>standard-warning-handler</code> is to print a message (but see
<code>standard-warning-hook</code>).  More precisely, the message is printed
to the port returned by <code>notification-output-port</code>.  The message is
formed by first printing the string <code>"Warning: "</code> to this port, and
then calling <code>write-condition-report</code> on <var>condition</var> and the port.

        <p><a name="index-muffle_002dwarning-2831"></a>In order to simulate the effect of calling <code>warn</code>, code may call
<code>signal-condition</code> directly and then call
<code>standard-warning-handler</code> if <code>signal-condition</code> returns. 
(This is not sufficient to implement the <code>muffle-warning</code> protocol,
however.  For that purpose an explicit restart must be provided.) 
</p></blockquote></div>

<div class="defun">
&mdash; variable: <b>standard-warning-hook</b><var><a name="index-standard_002dwarning_002dhook-2832"></a></var><br>
<blockquote><p><a name="index-standard_002dwarning_002dhandler-2833"></a><a name="index-fluid-binding-2834"></a><a name="index-dynamic-binding-2835"></a>This variable controls the behavior of the procedure
<code>standard-warning-handler</code>, and hence <code>warn</code>.  It is intended
to be bound with <code>fluid-let</code> and is normally <code>#f</code>.  It may be
changed to a procedure of one argument and will then be invoked (with
<code>standard-warning-hook</code> rebound to <code>#f</code>) by
<code>standard-warning-handler</code> in lieu of writing the warning message. 
It is passed one argument, the condition being signalled. 
</p></blockquote></div>

   </body></html>

