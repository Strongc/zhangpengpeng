<html lang="en">
<head>
<title>Fixnum Operations - MIT/GNU Scheme 9.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Fixnum-and-Flonum-Operations.html#Fixnum-and-Flonum-Operations" title="Fixnum and Flonum Operations">
<link rel="prev" href="Fixnum-and-Flonum-Operations.html#Fixnum-and-Flonum-Operations" title="Fixnum and Flonum Operations">
<link rel="next" href="Flonum-Operations.html#Flonum-Operations" title="Flonum Operations">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents MIT/GNU Scheme 9.0.1.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Fixnum-Operations"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Flonum-Operations.html#Flonum-Operations">Flonum Operations</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Fixnum-and-Flonum-Operations.html#Fixnum-and-Flonum-Operations">Fixnum and Flonum Operations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Fixnum-and-Flonum-Operations.html#Fixnum-and-Flonum-Operations">Fixnum and Flonum Operations</a>
<hr>
</div>

<h4 class="subsection">4.7.1 Fixnum Operations</h4>

<p><a name="index-fixnum-_0028defn_0029-599"></a>A <dfn>fixnum</dfn> is an exact integer that is small enough to fit in a
machine word.  In MIT/GNU Scheme, fixnums are typically 24 or 26 bits,
depending on the machine; it is reasonable to assume that fixnums are at
least 24 bits.  Fixnums are signed; they are encoded using 2's
complement.

   <p>All exact integers that are small enough to be encoded as fixnums are
always encoded as fixnums &mdash; in other words, any exact integer that is
not a fixnum is too big to be encoded as such.  For this reason, small
constants such as <code>0</code> or <code>1</code> are guaranteed to be fixnums.

<div class="defun">
&mdash; procedure: <b>fix:fixnum?</b><var> object<a name="index-fix_003afixnum_003f-600"></a></var><br>
<blockquote><p><a name="index-type-predicate_002c-for-fixnum-601"></a>Returns <code>#t</code> if <var>object</var> is a fixnum; otherwise returns
<code>#f</code>. 
</p></blockquote></div>

   <p>Here is an expression that determines the largest fixnum:

<pre class="example">     (let loop ((n 1))
       (if (fix:fixnum? n)
           (loop (* n 2))
           (- n 1)))
</pre>
   <p class="noindent">A similar expression determines the smallest fixnum.

<div class="defun">
&mdash; procedure: <b>fix:=</b><var> fixnum fixnum<a name="index-fix_003a_003d-602"></a></var><br>
&mdash; procedure: <b>fix:&lt;</b><var> fixnum fixnum<a name="index-fix_003a_003c-603"></a></var><br>
&mdash; procedure: <b>fix:&gt;</b><var> fixnum fixnum<a name="index-fix_003a_003e-604"></a></var><br>
&mdash; procedure: <b>fix:&lt;=</b><var> fixnum fixnum<a name="index-fix_003a_003c_003d-605"></a></var><br>
&mdash; procedure: <b>fix:&gt;=</b><var> fixnum fixnum<a name="index-fix_003a_003e_003d-606"></a></var><br>
<blockquote><p><a name="index-equivalence-predicate_002c-for-fixnums-607"></a>These are the standard order and equality predicates on fixnums.  When
compiled, they do not check the types of their arguments. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>fix:zero?</b><var> fixnum<a name="index-fix_003azero_003f-608"></a></var><br>
&mdash; procedure: <b>fix:positive?</b><var> fixnum<a name="index-fix_003apositive_003f-609"></a></var><br>
&mdash; procedure: <b>fix:negative?</b><var> fixnum<a name="index-fix_003anegative_003f-610"></a></var><br>
<blockquote><p>These procedures compare their argument to zero.  When compiled, they do
not check the type of their argument.  The code produced by the
following expressions is identical:

     <pre class="example">          (fix:zero? <var>fixnum</var>)
          (fix:= <var>fixnum</var> 0)
</pre>
        <p class="noindent">Similarly, <code>fix:positive?</code> and <code>fix:negative?</code> produce code
identical to equivalent expressions using <code>fix:&gt;</code> and <code>fix:&lt;</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>fix:+</b><var> fixnum fixnum<a name="index-fix_003a_002b-611"></a></var><br>
&mdash; procedure: <b>fix:-</b><var> fixnum fixnum<a name="index-fix_003a_002d-612"></a></var><br>
&mdash; procedure: <b>fix:*</b><var> fixnum fixnum<a name="index-fix_003a_002a-613"></a></var><br>
&mdash; procedure: <b>fix:quotient</b><var> fixnum fixnum<a name="index-fix_003aquotient-614"></a></var><br>
&mdash; procedure: <b>fix:remainder</b><var> fixnum fixnum<a name="index-fix_003aremainder-615"></a></var><br>
&mdash; procedure: <b>fix:gcd</b><var> fixnum fixnum<a name="index-fix_003agcd-616"></a></var><br>
&mdash; procedure: <b>fix:1+</b><var> fixnum<a name="index-fix_003a1_002b-617"></a></var><br>
&mdash; procedure: <b>fix:-1+</b><var> fixnum<a name="index-fix_003a_002d1_002b-618"></a></var><br>
<blockquote><p>These procedures are the standard arithmetic operations on fixnums. 
When compiled, they do not check the types of their arguments. 
Furthermore, they do not check to see if the result can be encoded as a
fixnum.  If the result is too large to be encoded as a fixnum, a
malformed object is returned, with potentially disastrous effect on the
garbage collector. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>fix:divide</b><var> fixnum fixnum<a name="index-fix_003adivide-619"></a></var><br>
<blockquote><p><a name="index-integer_002ddivide-620"></a><a name="index-integer_002ddivide_002dquotient-621"></a><a name="index-integer_002ddivide_002dremainder-622"></a>This procedure is like <code>integer-divide</code>, except that its arguments
and its results must be fixnums.  It should be used in conjunction with
<code>integer-divide-quotient</code> and <code>integer-divide-remainder</code>. 
</p></blockquote></div>

   <p><a name="index-logical-operations_002c-on-fixnums-623"></a><a name="index-bitwise_002dlogical-operations_002c-on-fixnums-624"></a>The following are <dfn>bitwise-logical</dfn> operations on fixnums.

<div class="defun">
&mdash; procedure: <b>fix:not</b><var> fixnum<a name="index-fix_003anot-625"></a></var><br>
<blockquote><p>This returns the bitwise-logical inverse of its argument.  When
compiled, it does not check the type of its argument.

     <pre class="example">          (fix:not 0)                             &rArr;  -1
          (fix:not -1)                            &rArr;  0
          (fix:not 1)                             &rArr;  -2
          (fix:not -34)                           &rArr;  33
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>fix:and</b><var> fixnum fixnum<a name="index-fix_003aand-626"></a></var><br>
<blockquote><p>This returns the bitwise-logical &ldquo;and&rdquo; of its arguments.  When
compiled, it does not check the types of its arguments.

     <pre class="example">          (fix:and #x43 #x0f)                     &rArr;  3
          (fix:and #x43 #xf0)                     &rArr;  #x40
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>fix:andc</b><var> fixnum fixnum<a name="index-fix_003aandc-627"></a></var><br>
<blockquote><p>Returns the bitwise-logical &ldquo;and&rdquo; of the first argument with the
bitwise-logical inverse of the second argument.  When compiled, it does
not check the types of its arguments.

     <pre class="example">          (fix:andc #x43 #x0f)                    &rArr;  #x40
          (fix:andc #x43 #xf0)                    &rArr;  3
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>fix:or</b><var> fixnum fixnum<a name="index-fix_003aor-628"></a></var><br>
<blockquote><p>This returns the bitwise-logical &ldquo;inclusive or&rdquo; of its arguments. 
When compiled, it does not check the types of its arguments.

     <pre class="example">          (fix:or #x40 3)                         &rArr; #x43
          (fix:or #x41 3)                         &rArr; #x43
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>fix:xor</b><var> fixnum fixnum<a name="index-fix_003axor-629"></a></var><br>
<blockquote><p>This returns the bitwise-logical &ldquo;exclusive or&rdquo; of its arguments. 
When compiled, it does not check the types of its arguments.

     <pre class="example">          (fix:xor #x40 3)                        &rArr; #x43
          (fix:xor #x41 3)                        &rArr; #x42
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>fix:lsh</b><var> fixnum1 fixnum2<a name="index-fix_003alsh-630"></a></var><br>
<blockquote><p>This procedure returns the result of logically shifting <var>fixnum1</var> by
<var>fixnum2</var> bits.  If <var>fixnum2</var> is positive, <var>fixnum1</var> is
shifted left; if negative, it is shifted right.  When compiled, it does
not check the types of its arguments, nor the validity of its result.

     <pre class="example">          (fix:lsh 1 10)                          &rArr;  #x400
          (fix:lsh #x432 -10)                     &rArr;  1
          (fix:lsh -1 3)                          &rArr;  -8
          (fix:lsh -128 -4)                       &rArr;  #x3FFFF8
</pre>
        </blockquote></div>

   </body></html>

