<html lang="en">
<head>
<title>Equivalence Predicates - MIT/GNU Scheme 9.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="Special-Forms.html#Special-Forms" title="Special Forms">
<link rel="next" href="Numbers.html#Numbers" title="Numbers">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents MIT/GNU Scheme 9.0.1.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Equivalence-Predicates"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Numbers.html#Numbers">Numbers</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Special-Forms.html#Special-Forms">Special Forms</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<h2 class="chapter">3 Equivalence Predicates</h2>

<p><a name="index-predicate-_0028defn_0029-415"></a><a name="index-predicate_002c-equivalence-_0028defn_0029-416"></a><a name="index-equivalence-predicate-_0028defn_0029-417"></a><a name="index-comparison_002c-for-equivalence-418"></a><a name="index-eq_003f-419"></a><a name="index-eqv_003f-420"></a><a name="index-equal_003f-421"></a>A <dfn>predicate</dfn> is a procedure that always returns a boolean value
(<code>#t</code> or <code>#f</code>).  An <dfn>equivalence predicate</dfn> is the
computational analogue of a mathematical equivalence relation (it is
symmetric, reflexive, and transitive).  Of the equivalence predicates
described in this section, <code>eq?</code> is the finest or most
discriminating, and <code>equal?</code> is the coarsest.  <code>eqv?</code> is
slightly less discriminating than <code>eq?</code>.

<div class="defun">
&mdash; procedure: <b>eqv?</b><var> obj1 obj2<a name="index-eqv_003f-422"></a></var><br>
<blockquote><p>The <code>eqv?</code> procedure defines a useful equivalence relation on
objects.  Briefly, it returns <code>#t</code> if <var>obj1</var> and <var>obj2</var>
should normally be regarded as the same object.

        <p>The <code>eqv?</code> procedure returns <code>#t</code> if:

          <ul>
<li><var>obj1</var> and <var>obj2</var> are both <code>#t</code> or both <code>#f</code>.

          <li><var>obj1</var> and <var>obj2</var> are both interned symbols and

          <pre class="example">               (string=? (symbol-&gt;string <var>obj1</var>)
                         (symbol-&gt;string <var>obj2</var>))
                    &rArr; #t
</pre>
          <p><a name="index-string_003d_003f-423"></a><a name="index-symbol_002d_003estring-424"></a>
<li><var>obj1</var> and <var>obj2</var> are both numbers, are numerically equal
according to the <code>=</code> procedure, and are either both exact or both
inexact (see <a href="Numbers.html#Numbers">Numbers</a>). 
<a name="index-g_t_003d-425"></a>
<li><var>obj1</var> and <var>obj2</var> are both characters and are the same character
according to the <code>char=?</code> procedure (see <a href="Characters.html#Characters">Characters</a>). 
<a name="index-char_003d_003f-426"></a>
<li>both <var>obj1</var> and <var>obj2</var> are the empty list.

          <li><var>obj1</var> and <var>obj2</var> are procedures whose location tags are equal.

          <li><var>obj1</var> and <var>obj2</var> are pairs, vectors, strings, bit strings,
records, cells, or weak pairs that denote the same locations in the
store. 
</ul>

     <p class="noindent">The <code>eqv?</code> procedure returns <code>#f</code> if:

          <ul>
<li><var>obj1</var> and <var>obj2</var> are of different types.

          <li>one of <var>obj1</var> and <var>obj2</var> is <code>#t</code> but the other is
<code>#f</code>.

          <li><var>obj1</var> and <var>obj2</var> are symbols but

          <pre class="example">               (string=? (symbol-&gt;string <var>obj1</var>)
                         (symbol-&gt;string <var>obj2</var>))
                    &rArr; #f
</pre>
          <p><a name="index-string_003d_003f-427"></a><a name="index-symbol_002d_003estring-428"></a>
<li>one of <var>obj1</var> and <var>obj2</var> is an exact number but the other is an
inexact number.

          <li><var>obj1</var> and <var>obj2</var> are numbers for which the <code>=</code> procedure
returns <code>#f</code>. 
<a name="index-g_t_003d-429"></a>
<li><var>obj1</var> and <var>obj2</var> are characters for which the <code>char=?</code>
procedure returns <code>#f</code>. 
<a name="index-char_003d_003f-430"></a>
<li>one of <var>obj1</var> and <var>obj2</var> is the empty list but the other is not.

          <li><var>obj1</var> and <var>obj2</var> are procedures that would behave differently
(return a different value or have different side effects) for some
arguments.

          <li><var>obj1</var> and <var>obj2</var> are pairs, vectors, strings, bit strings,
records, cells, or weak pairs that denote distinct locations. 
</ul>

        <p>Some examples:

     <pre class="example">          (eqv? 'a 'a)                    &rArr;  #t
          (eqv? 'a 'b)                    &rArr;  #f
          (eqv? 2 2)                      &rArr;  #t
          (eqv? '() '())                  &rArr;  #t
          (eqv? 100000000 100000000)      &rArr;  #t
          (eqv? (cons 1 2) (cons 1 2))    &rArr;  #f
          (eqv? (lambda () 1)
                (lambda () 2))            &rArr;  #f
          (eqv? #f 'nil)                  &rArr;  #f
          (let ((p (lambda (x) x)))
            (eqv? p p))                   &rArr;  #t
</pre>
        <p>The following examples illustrate cases in which the above rules do not
fully specify the behavior of <code>eqv?</code>.  All that can be said about
such cases is that the value returned by <code>eqv?</code> must be a boolean.

     <pre class="example">          (eqv? "" "")                    &rArr;  <span class="roman">unspecified</span>
          (eqv? '#() '#())                &rArr;  <span class="roman">unspecified</span>
          (eqv? (lambda (x) x)
                (lambda (x) x))           &rArr;  <span class="roman">unspecified</span>
          (eqv? (lambda (x) x)
                (lambda (y) y))           &rArr;  <span class="roman">unspecified</span>
</pre>
        <p>The next set of examples shows the use of <code>eqv?</code> with procedures
that have local state.  <code>gen-counter</code> must return a distinct
procedure every time, since each procedure has its own internal counter. 
<code>gen-loser</code>, however, returns equivalent procedures each time,
since the local state does not affect the value or side effects of the
procedures.

     <pre class="example">          (define gen-counter
            (lambda ()
              (let ((n 0))
                (lambda () (set! n (+ n 1)) n))))
          (let ((g (gen-counter)))
            (eqv? g g))                   &rArr;  #t
          (eqv? (gen-counter) (gen-counter))
                                          &rArr;  #f
          
          (define gen-loser
            (lambda ()
              (let ((n 0))
                (lambda () (set! n (+ n 1)) 27))))
          (let ((g (gen-loser)))
            (eqv? g g))                   &rArr;  #t
          (eqv? (gen-loser) (gen-loser))
                                          &rArr;  <span class="roman">unspecified</span>
          
          (letrec ((f (lambda () (if (eqv? f g) 'both 'f)))
                   (g (lambda () (if (eqv? f g) 'both 'g)))
            (eqv? f g))
                                          &rArr;  <span class="roman">unspecified</span>
          
          (letrec ((f (lambda () (if (eqv? f g) 'f 'both)))
                   (g (lambda () (if (eqv? f g) 'g 'both)))
            (eqv? f g))
                                          &rArr;  #f
</pre>
        <p>Objects of distinct types must never be regarded as the same object.

        <p>Since it is an error to modify constant objects (those returned by
literal expressions), the implementation may share structure between
constants where appropriate.  Thus the value of <code>eqv?</code> on constants
is sometimes unspecified.

     <pre class="example">          (let ((x '(a)))
            (eqv? x x))                    &rArr;  #t
          (eqv? '(a) '(a))                 &rArr;  <span class="roman">unspecified</span>
          (eqv? "a" "a")                   &rArr;  <span class="roman">unspecified</span>
          (eqv? '(b) (cdr '(a b)))         &rArr;  <span class="roman">unspecified</span>
</pre>
        <p>Rationale: The above definition of <code>eqv?</code> allows implementations
latitude in their treatment of procedures and literals: implementations
are free either to detect or to fail to detect that two procedures or
two literals are equivalent to each other, and can decide whether or not
to merge representations of equivalent objects by using the same pointer
or bit pattern to represent both. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>eq?</b><var> obj1 obj2<a name="index-eq_003f-431"></a></var><br>
<blockquote><p><code>eq?</code> is similar to <code>eqv?</code> except that in some cases it is
capable of discerning distinctions finer than those detectable by
<code>eqv?</code>.

        <p><code>eq?</code> and <code>eqv?</code> are guaranteed to have the same behavior on
symbols, booleans, the empty list, pairs, records, and non-empty strings
and vectors.  <code>eq?</code>'s behavior on numbers and characters is
implementation-dependent, but it will always return either true or
false, and will return true only when <code>eqv?</code> would also return
true.  <code>eq?</code> may also behave differently from <code>eqv?</code> on empty
vectors and empty strings.

     <pre class="example">          (eq? 'a 'a)                     &rArr;  #t
          (eq? '(a) '(a))                 &rArr;  <span class="roman">unspecified</span>
          (eq? (list 'a) (list 'a))       &rArr;  #f
          (eq? "a" "a")                   &rArr;  <span class="roman">unspecified</span>
          (eq? "" "")                     &rArr;  <span class="roman">unspecified</span>
          (eq? '() '())                   &rArr;  #t
          (eq? 2 2)                       &rArr;  <span class="roman">unspecified</span>
          (eq? #\A #\A)                   &rArr;  <span class="roman">unspecified</span>
          (eq? car car)                   &rArr;  #t
          (let ((n (+ 2 3)))
            (eq? n n))                    &rArr;  <span class="roman">unspecified</span>
          (let ((x '(a)))
            (eq? x x))                    &rArr;  #t
          (let ((x '#()))
            (eq? x x))                    &rArr;  #t
          (let ((p (lambda (x) x)))
            (eq? p p))                    &rArr;  #t
</pre>
        <p>Rationale: It will usually be possible to implement <code>eq?</code> much more
efficiently than <code>eqv?</code>, for example, as a simple pointer
comparison instead of as some more complicated operation.  One reason is
that it may not be possible to compute <code>eqv?</code> of two numbers in
constant time, whereas <code>eq?</code> implemented as pointer comparison will
always finish in constant time.  <code>eq?</code> may be used like <code>eqv?</code>
in applications using procedures to implement objects with state since
it obeys the same constraints as <code>eqv?</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>equal?</b><var> obj1 obj2<a name="index-equal_003f-432"></a></var><br>
<blockquote><p><a name="index-circular-structure-433"></a><code>equal?</code> recursively compares the contents of pairs, vectors, and
strings, applying <code>eqv?</code> on other objects such as numbers, symbols,
and records.  A rule of thumb is that objects are generally
<code>equal?</code> if they print the same.  <code>equal?</code> may fail to
terminate if its arguments are circular data structures.

     <pre class="example">          (equal? 'a 'a)                  &rArr;  #t
          (equal? '(a) '(a))              &rArr;  #t
          (equal? '(a (b) c)
                  '(a (b) c))             &rArr;  #t
          (equal? "abc" "abc")            &rArr;  #t
          (equal? 2 2)                    &rArr;  #t
          (equal? (make-vector 5 'a)
                  (make-vector 5 'a))     &rArr;  #t
          (equal? (lambda (x) x)
                  (lambda (y) y))         &rArr;  <span class="roman">unspecified</span>
</pre>
        </blockquote></div>

   </body></html>

