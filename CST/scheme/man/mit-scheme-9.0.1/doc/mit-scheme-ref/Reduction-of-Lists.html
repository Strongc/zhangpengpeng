<html lang="en">
<head>
<title>Reduction of Lists - MIT/GNU Scheme 9.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Lists.html#Lists" title="Lists">
<link rel="prev" href="Mapping-of-Lists.html#Mapping-of-Lists" title="Mapping of Lists">
<link rel="next" href="Miscellaneous-List-Operations.html#Miscellaneous-List-Operations" title="Miscellaneous List Operations">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents MIT/GNU Scheme 9.0.1.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Reduction-of-Lists"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Miscellaneous-List-Operations.html#Miscellaneous-List-Operations">Miscellaneous List Operations</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Mapping-of-Lists.html#Mapping-of-Lists">Mapping of Lists</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Lists.html#Lists">Lists</a>
<hr>
</div>

<h3 class="section">7.8 Reduction of Lists</h3>

<p><a name="index-reduction_002c-of-list-1289"></a>

<div class="defun">
&mdash; procedure: <b>reduce-left</b><var> procedure initial list<a name="index-reduce_002dleft-1290"></a></var><br>
<blockquote><p>Combines all the elements of <var>list</var> using the binary operation
<var>procedure</var>.  For example, using <code>+</code> one can add up all the
elements:

     <pre class="example">          (reduce-left + 0 list-of-numbers)
</pre>
        <p>The argument <var>initial</var> is used only if <var>list</var> is empty; in this
case <var>initial</var> is the result of the call to <code>reduce-left</code>.  If
<var>list</var> has a single argument, it is returned.  Otherwise, the arguments
are reduced in a left-associative fashion.  For example:

     <pre class="example">          (reduce-left + 0 '(1 2 3 4))            &rArr; 10
          (reduce-left + 0 '(1 2))                &rArr; 3
          (reduce-left + 0 '(1))                  &rArr; 1
          (reduce-left + 0 '())                   &rArr; 0
          (reduce-left + 0 '(foo))                &rArr; foo
          (reduce-left list '() '(1 2 3 4))       &rArr; (((1 2) 3) 4)
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>reduce-right</b><var> procedure initial list<a name="index-reduce_002dright-1291"></a></var><br>
<blockquote><p>Like <code>reduce-left</code> except that it is right-associative.

     <pre class="example">          (reduce-right list '() '(1 2 3 4))      &rArr; (1 (2 (3 4)))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>fold-right</b><var> procedure initial list<a name="index-fold_002dright-1292"></a></var><br>
<blockquote><p>Combines all of the elements of <var>list</var> using the binary operation
<var>procedure</var>.  Unlike <code>reduce-left</code> and <code>reduce-right</code>,
<var>initial</var> is always used:

     <pre class="example">          (fold-right + 0 '(1 2 3 4))             &rArr; 10
          (fold-right + 0 '(foo))                 error--&gt; Illegal datum
          (fold-right list '() '(1 2 3 4))        &rArr; (1 (2 (3 (4 ()))))
</pre>
        <p><code>Fold-right</code> has interesting properties because it establishes a
homomorphism between (<code>cons</code>, <code>()</code>) and (<var>procedure</var>,
<var>initial</var>).  It can be thought of as replacing the pairs in the
spine of the list with <var>procedure</var> and replacing the <code>()</code> at
the end with <var>initial</var>.  Many of the classical list-processing
procedures can be expressed in terms of <code>fold-right</code>, at least for
the simple versions that take a fixed number of arguments:

     <pre class="example">          (define (copy-list list)
            (fold-right cons '() list))
          
          (define (append list1 list2)
            (fold-right cons list2 list1))
          
          (define (map p list)
            (fold-right (lambda (x r) (cons (p x) r)) '() list))
          
          (define (reverse items)
            (fold-right (lambda (x r) (append r (list x))) '() items))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>fold-left</b><var> procedure initial list<a name="index-fold_002dleft-1293"></a></var><br>
<blockquote><p>Combines all the elements of <var>list</var> using the binary operation
<var>procedure</var>.  Elements are combined starting with <var>initial</var> and
then the elements of <var>list</var> from left to right.  Whereas
<code>fold-right</code> is recursive in nature, capturing the essence of
<code>cdr</code>-ing down a list and then computing a result, <var>fold-left</var>
is iterative in nature, combining the elements as the list is traversed.

     <pre class="example">          (fold-left list '() '(1 2 3 4))         &rArr; ((((() 1) 2) 3) 4)
          
          (define (length list)
            (fold-left (lambda (sum element) (+ sum 1)) 0 list))
          
          (define (reverse items)
            (fold-left (lambda (x y) (cons y x)) () items))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; procedure: <b>any</b><var> predicate list list <small class="dots">...</small><a name="index-any-1294"></a></var><br>
<blockquote><p>(<acronym>SRFI</acronym> 1) Applies <var>predicate</var> across the <var>list</var>s,
returning true if <var>predicate</var> returns true on any application.

        <p>If there are n list arguments <var>list1</var> <small class="dots">...</small>  <var>listn</var>,
then <var>predicate</var> must be a procedure taking n arguments and
returning a boolean result.

        <p><code>any</code> applies <var>predicate</var> to the first elements of the
<var>list</var> parameters.  If this application returns a true value,
<code>any</code> immediately returns that value.  Otherwise, it iterates,
applying <var>predicate</var> to the second elements of the <var>list</var>
parameters, then the third, and so forth.  The iteration stops when a
true value is produced or one of the lists runs out of values; in the
latter case, <code>any</code> returns <code>#f</code>.  The application of
<var>predicate</var> to the last element of the <var>list</var>s is a tail call.

        <p>Note the difference between <code>find</code> and <code>any</code>&mdash;<code>find</code>
returns the element that satisfied the predicate; <code>any</code> returns
the true value that the <var>predicate</var> produced.

        <p>Like <code>every</code>, <code>any</code>'s name does not end with a question
mark&mdash;this is to indicate that it does not return a simple boolean
(<code>#t</code> or <code>#f</code>), but a general value.

     <pre class="example">          (any integer? '(a 3 b 2.7))   =&gt; #t
          (any integer? '(a 3.1 b 2.7)) =&gt; #f
          (any &lt; '(3 1 4 1 5)
                 '(2 7 1 8 2)) =&gt; #t
</pre>
        <p><a name="index-there_002dexists_003f-1295"></a>The non-standard procedure <code>there-exists?</code> is similar, except
that it takes a single list and a predicate argument, in that order. 
</p></blockquote></div>

<div class="defun">
&mdash; procedure: <b>every</b><var> predicate list list <small class="dots">...</small><a name="index-every-1296"></a></var><br>
<blockquote><p>(<acronym>SRFI</acronym> 1) Applies <var>predicate</var> across the <var>list</var>s,
returning true if <var>predicate</var> returns true on every application.

        <p>If there are n list arguments <var>list1</var> <small class="dots">...</small>  <var>listn</var>,
then <var>predicate</var> must be a procedure taking n arguments and
returning a boolean result.

        <p><code>every</code> applies <var>predicate</var> to the first elements of the
<var>list</var> parameters.  If this application returns false,
<code>every</code> immediately returns false.  Otherwise, it iterates,
applying <var>predicate</var> to the second elements of the <var>list</var>
parameters, then the third, and so forth.  The iteration stops when a
false value is produced or one of the <var>list</var>s runs out of values. 
In the latter case, <code>every</code> returns the true value produced by
its final application of <var>predicate</var>.  The application of
<var>predicate</var> to the last element of the <var>list</var>s is a tail call.

        <p>If one of the clisti has no elements, <code>every</code> simply returns <code>#t</code>.

        <p>Like <code>any</code>, <code>every</code>'s name does not end with a question
mark&mdash;this is to indicate that it does not return a simple boolean
(<code>#t</code> or <code>#f</code>), but a general value.

        <p><a name="index-for_002dall_003f-1297"></a>The non-standard procedure <code>for-all?</code> is similar, except
that it takes a single list and a predicate argument, in that order. 
</p></blockquote></div>

   </body></html>

