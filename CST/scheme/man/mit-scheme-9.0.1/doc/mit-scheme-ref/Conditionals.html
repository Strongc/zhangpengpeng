<html lang="en">
<head>
<title>Conditionals - MIT/GNU Scheme 9.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Special-Forms.html#Special-Forms" title="Special Forms">
<link rel="prev" href="Quoting.html#Quoting" title="Quoting">
<link rel="next" href="Sequencing.html#Sequencing" title="Sequencing">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents MIT/GNU Scheme 9.0.1.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Conditionals"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Sequencing.html#Sequencing">Sequencing</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Quoting.html#Quoting">Quoting</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Special-Forms.html#Special-Forms">Special Forms</a>
<hr>
</div>

<h3 class="section">2.7 Conditionals</h3>

<p><a name="index-expression_002c-conditional-_0028defn_0029-299"></a><a name="index-conditional-expression-_0028defn_0029-300"></a><a name="index-true_002c-in-conditional-expression-_0028defn_0029-301"></a><a name="index-false_002c-in-conditional-expression-_0028defn_0029-302"></a><a name="index-g_t_0023f-303"></a><a name="index-g_t_0023t-304"></a>The behavior of the <dfn>conditional expressions</dfn> is determined by
whether objects are true or false.  The conditional expressions count
only <code>#f</code> as false.  They count everything else, including
<code>#t</code>, pairs, symbols, numbers, strings, vectors, and procedures as
true (but see <a href="True-and-False.html#True-and-False">True and False</a>).

   <p>In the descriptions that follow, we say that an object has &ldquo;a true
value&rdquo; or &ldquo;is true&rdquo; when the conditional expressions treat it as
true, and we say that an object has &ldquo;a false value&rdquo; or &ldquo;is false&rdquo;
when the conditional expressions treat it as false.

<div class="defun">
&mdash; special form: <b>if</b><var> predicate consequent </var>[<var>alternative</var>]<var><a name="index-if-305"></a></var><br>
<blockquote><p><var>Predicate</var>, <var>consequent</var>, and <var>alternative</var> are
expressions.  An <code>if</code> expression is evaluated as follows: first,
<var>predicate</var> is evaluated.  If it yields a true value, then
<var>consequent</var> is evaluated and its value is returned.  Otherwise
<var>alternative</var> is evaluated and its value is returned.  If
<var>predicate</var> yields a false value and no <var>alternative</var> is
specified, then the result of the expression is unspecified.

        <p>An <code>if</code> expression evaluates either <var>consequent</var> or
<var>alternative</var>, never both.  Programs should not depend on the value
of an <code>if</code> expression that has no <var>alternative</var>.

     <pre class="example">          (if (&gt; 3 2) 'yes 'no)                   &rArr;  yes
          (if (&gt; 2 3) 'yes 'no)                   &rArr;  no
          (if (&gt; 3 2)
              (- 3 2)
              (+ 3 2))                            &rArr;  1
</pre>
        </blockquote></div>

<div class="defun">
&mdash; special form: <b>cond</b><var> clause clause <small class="dots">...</small><a name="index-cond-306"></a></var><br>
<blockquote><p><a name="index-cond-clause-307"></a><a name="index-clause_002c-of-cond-expression-308"></a>Each <var>clause</var> has this form:

     <pre class="example">          (<var>predicate</var> <var>expression</var> ...)
</pre>
        <p class="noindent"><a name="index-else-clause_002c-of-cond-expression-_0028defn_0029-309"></a><a name="index-else-310"></a>where <var>predicate</var> is any expression.  The last <var>clause</var> may be
an <code>else</code><dfn> clause</dfn>, which has the form:

     <pre class="example">          (else <var>expression</var> <var>expression</var> ...)
</pre>
        <p>A <code>cond</code> expression does the following:

          <ol type=1 start=1>
<li>Evaluates the <var>predicate</var> expressions of successive <var>clause</var>s in
order, until one of the <var>predicate</var>s evaluates to a true
value.

          <li>When a <var>predicate</var> evaluates to a true value, <code>cond</code> evaluates
the <var>expression</var>s in the associated <var>clause</var> in left to right
order, and returns the result of evaluating the last <var>expression</var> in
the <var>clause</var> as the result of the entire <code>cond</code> expression.

          <p>If the selected <var>clause</var> contains only the <var>predicate</var> and no
<var>expression</var>s, <code>cond</code> returns the value of the <var>predicate</var>
as the result.

          <li>If all <var>predicate</var>s evaluate to false values, and there is no
<code>else</code> clause, the result of the conditional expression is
unspecified; if there is an <code>else</code> clause, <code>cond</code> evaluates
its <var>expression</var>s (left to right) and returns the value of the last
one.
             </ol>

     <pre class="example">          (cond ((&gt; 3 2) 'greater)
                ((&lt; 3 2) 'less))                  &rArr;  greater
          
          (cond ((&gt; 3 3) 'greater)
                ((&lt; 3 3) 'less)
                (else 'equal))                    &rArr;  equal
</pre>
        <p>Normally, programs should not depend on the value of a <code>cond</code>
expression that has no <code>else</code> clause.  However, some Scheme
programmers prefer to write <code>cond</code> expressions in which at least
one of the <var>predicate</var>s is always true.  In this style, the final
<var>clause</var> is equivalent to an <code>else</code> clause.

        <p><a name="index-g_t_003d_003e-in-cond-clause-311"></a><a name="index-g_t_003d_003e-312"></a>Scheme supports an alternative <var>clause</var> syntax:

     <pre class="example">          (<var>predicate</var> =&gt; <var>recipient</var>)
</pre>
        <p class="noindent">where <var>recipient</var> is an expression.  If <var>predicate</var> evaluates to
a true value, then <var>recipient</var> is evaluated.  Its value must be a
procedure of one argument; this procedure is then invoked on the value
of the <var>predicate</var>.

     <pre class="example">          (cond ((assv 'b '((a 1) (b 2))) =&gt; cadr)
                (else #f))                        &rArr;  2
</pre>
        </blockquote></div>

<div class="defun">
&mdash; special form: <b>case</b><var> key clause clause <small class="dots">...</small><a name="index-case-313"></a></var><br>
<blockquote><p><a name="index-case-clause-314"></a><a name="index-clause_002c-of-case-expression-315"></a><var>Key</var> may be any expression.  Each <var>clause</var> has this
form:

     <pre class="example">          ((<var>object</var> ...) <var>expression</var> <var>expression</var> ...)
</pre>
        <p><a name="index-else-clause_002c-of-case-expression-_0028defn_0029-316"></a><a name="index-else-317"></a>No <var>object</var> is evaluated, and all the <var>object</var>s must be
distinct.  The last <var>clause</var> may be an <code>else</code><dfn> clause</dfn>,
which has the form:

     <pre class="example">          (else <var>expression</var> <var>expression</var> ...)
</pre>
        <p>A <code>case</code> expression does the following:

          <ol type=1 start=1>
<li>Evaluates <var>key</var> and compares the result with each
<var>object</var>.

          <li>If the result of evaluating <var>key</var> is equivalent (in the sense of
<code>eqv?</code>; see <a href="Equivalence-Predicates.html#Equivalence-Predicates">Equivalence Predicates</a>) to an <var>object</var>,
<code>case</code> evaluates the <var>expression</var>s in the corresponding
<var>clause</var> from left to right and returns the result of evaluating the
last <var>expression</var> in the <var>clause</var> as the result of the
<code>case</code> expression. 
<a name="index-eqv_003f-318"></a>
<li>If the result of evaluating <var>key</var> is different from every
<var>object</var>, and if there's an <code>else</code> clause, <code>case</code>
evaluates its <var>expression</var>s and returns the result of the last one
as the result of the <code>case</code> expression.  If there's no <code>else</code>
clause, <code>case</code> returns an unspecified result.  Programs should not
depend on the value of a <code>case</code> expression that has no <code>else</code>
clause.
             </ol>

        <p>For example,

     <pre class="example">          (case (* 2 3)
             ((2 3 5 7) 'prime)
             ((1 4 6 8 9) 'composite))            &rArr;  composite
          
          (case (car '(c d))
             ((a) 'a)
             ((b) 'b))                            &rArr;  <span class="roman">unspecified</span>
          
          (case (car '(c d))
             ((a e i o u) 'vowel)
             ((w y) 'semivowel)
             (else 'consonant))                   &rArr;  consonant
</pre>
        </blockquote></div>

<div class="defun">
&mdash; special form: <b>and</b><var> expression <small class="dots">...</small><a name="index-and-319"></a></var><br>
<blockquote><p>The <var>expression</var>s are evaluated from left to right, and the value of
the first <var>expression</var> that evaluates to a false value is returned. 
Any remaining <var>expression</var>s are not evaluated.  If all the
<var>expression</var>s evaluate to true values, the value of the last
<var>expression</var> is returned.  If there are no <var>expression</var>s then
<code>#t</code> is returned.

     <pre class="example">          (and (= 2 2) (&gt; 2 1))                   &rArr;  #t
          (and (= 2 2) (&lt; 2 1))                   &rArr;  #f
          (and 1 2 'c '(f g))                     &rArr;  (f g)
          (and)                                   &rArr;  #t
</pre>
        </blockquote></div>

<div class="defun">
&mdash; special form: <b>or</b><var> expression <small class="dots">...</small><a name="index-or-320"></a></var><br>
<blockquote><p>The <var>expression</var>s are evaluated from left to right, and the value of
the first <var>expression</var> that evaluates to a true value is returned. 
Any remaining <var>expression</var>s are not evaluated.  If all
<var>expression</var>s evaluate to false values, the value of the last
<var>expression</var> is returned.  If there are no <var>expression</var>s then
<code>#f</code> is returned.

     <pre class="example">          (or (= 2 2) (&gt; 2 1))                    &rArr;  #t
          (or (= 2 2) (&lt; 2 1))                    &rArr;  #t
          (or #f #f #f)                           &rArr;  #f
          (or (memq 'b '(a b c)) (/ 3 0))         &rArr;  (b c)
</pre>
        </blockquote></div>

   </body></html>

