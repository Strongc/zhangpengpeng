<html lang="en">
<head>
<title>Structure Definitions - MIT/GNU Scheme 9.0.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="MIT/GNU Scheme 9.0.1">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Special-Forms.html#Special-Forms" title="Special Forms">
<link rel="prev" href="Iteration.html#Iteration" title="Iteration">
<link rel="next" href="Macros.html#Macros" title="Macros">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents MIT/GNU Scheme 9.0.1.

Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993,
    1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2006, 2007, 2008, 2009, 2010 Massachusetts Institute of
    Technology

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual,'' and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License.''

     (a) The FSF's Back-Cover Text is: ``You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development.''
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Structure-Definitions"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Macros.html#Macros">Macros</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Iteration.html#Iteration">Iteration</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Special-Forms.html#Special-Forms">Special Forms</a>
<hr>
</div>

<h3 class="section">2.10 Structure Definitions</h3>

<p>This section provides examples and describes the options and syntax of
<code>define-structure</code>, an MIT/GNU Scheme macro that is very similar to
<code>defstruct</code> in Common Lisp.  The differences between them are
summarized at the end of this section.  For more information, see
Steele's Common Lisp book.

<div class="defun">
&mdash; special form: <b>define-structure</b> (<var>name structure-option <small class="dots">...</small></var>)<var> slot-description <small class="dots">...</small><a name="index-define_002dstructure-345"></a></var><br>
<blockquote><p>Each <var>slot-description</var> takes one of the following forms:

     <pre class="example">          <var>slot-name</var>
          (<var>slot-name</var> <var>default-init</var> [<var>slot-option</var> <var>value</var>]*)
</pre>
        <p><a name="index-keyword-constructor-346"></a><a name="index-BOA-constructor-347"></a>The fields <var>name</var> and <var>slot-name</var> must both be symbols.  The
field <var>default-init</var> is an expression for the initial value of the
slot.  It is evaluated each time a new instance is constructed.  If it
is not specified, the initial content of the slot is undefined.  Default
values are only useful with a <span class="sc">boa</span> constructor with argument list or
a keyword constructor (see below).

        <p>Evaluation of a <code>define-structure</code> expression defines a structure
descriptor and a set of procedures to manipulate instances of the
structure.  These instances are represented as records by default
(see <a href="Records.html#Records">Records</a>) but may alternately be lists or vectors.  The
accessors and modifiers are marked with compiler declarations so that
calls to them are automatically transformed into appropriate references. 
Often, no options are required, so a simple call to
<code>define-structure</code> looks like:

     <pre class="example">          (define-structure foo a b c)
</pre>
        <p>This defines a type descriptor <code>rtd:foo</code>, a constructor
<code>make-foo</code>, a predicate <code>foo?</code>, accessors <code>foo-a</code>,
<code>foo-b</code>, and <code>foo-c</code>, and modifiers <code>set-foo-a!</code>,
<code>set-foo-b!</code>, and <code>set-foo-c!</code>.

        <p>In general, if no options are specified, <code>define-structure</code> defines
the following (using the simple call above as an example):

          <dl>
<dt>type descriptor<dd>The name of the type descriptor is <code>"rtd:"</code> followed by the name of
the structure, e.g. &lsquo;<samp><span class="samp">rtd:foo</span></samp>&rsquo;.  The type descriptor satisfies the
predicate <code>record-type?</code>.

          <br><dt>constructor<dd>The name of the constructor is <code>"make-"</code> followed by the name of
the structure, e.g. &lsquo;<samp><span class="samp">make-foo</span></samp>&rsquo;.  The number of arguments accepted
by the constructor is the same as the number of slots; the arguments are
the initial values for the slots, and the order of the arguments matches
the order of the slot definitions.

          <br><dt>predicate<dd>The name of the predicate is the name of the structure followed by
<code>"?"</code>, e.g. &lsquo;<samp><span class="samp">foo?</span></samp>&rsquo;.  The predicate is a procedure of one
argument, which returns <code>#t</code> if its argument is a record of the
type defined by this structure definition, and <code>#f</code> otherwise.

          <br><dt>accessors<dd>For each slot, an accessor is defined.  The name of the accessor is
formed by appending the name of the structure, a hyphen, and the name of
the slot, e.g. &lsquo;<samp><span class="samp">foo-a</span></samp>&rsquo;.  The accessor is a procedure of one
argument, which must be a record of the type defined by this structure
definition.  The accessor extracts the contents of the corresponding
slot in that record and returns it.

          <br><dt>modifiers<dd>For each slot, a modifier is defined.  The name of the modifier is
formed by appending <code>"set-"</code>, the name of the accessor, and
<code>"!"</code>, e.g. &lsquo;<samp><span class="samp">set-foo-a!</span></samp>&rsquo;.  The modifier is a procedure of
two arguments, the first of which must be a record of the type defined
by this structure definition, and the second of which may be any object. 
The modifier modifies the contents of the corresponding slot in that
record to be that object, and returns an unspecified value. 
</dl>

        <p>When options are not supplied, <code>(</code><var>name</var><code>)</code> may be abbreviated to
<var>name</var>.  This convention holds equally for <var>structure-options</var>
and <var>slot-options</var>.  Hence, these are equivalent:

     <pre class="example">          (define-structure foo a b c)
          (define-structure (foo) (a) b (c))
</pre>
        <p class="noindent">as are

     <pre class="example">          (define-structure (foo keyword-constructor) a b c)
          (define-structure (foo (keyword-constructor)) a b c)
</pre>
        <p>When specified as option values, <code>false</code> and <code>nil</code> are
equivalent to <code>#f</code>, and <code>true</code> and <code>t</code> are equivalent to
<code>#t</code>. 
</p></blockquote></div>

   <p>Possible <var>slot-options</var> are:

<div class="defun">
&mdash; slot option: <b>read-only</b><var> value<a name="index-read_002donly-348"></a></var><br>
<blockquote><p>When given a <var>value</var> other than <code>#f</code>, this specifies that no
modifier should be created for the slot. 
</p></blockquote></div>

<div class="defun">
&mdash; slot option: <b>type</b><var> type-descriptor<a name="index-type-349"></a></var><br>
<blockquote><p>This is accepted but not presently used. 
</p></blockquote></div>

   <p>Possible <var>structure-options</var> are:

<div class="defun">
&mdash; structure option: <b>predicate</b> [<var>name</var>]<var><a name="index-predicate-350"></a></var><br>
<blockquote><p>This option controls the definition of a predicate procedure for the
structure.  If <var>name</var> is not given, the predicate is defined with
the default name (see above).  If <var>name</var> is <code>#f</code>, the predicate
is not defined at all.  Otherwise, <var>name</var> must be a symbol, and
the predicate is defined with that symbol as its name. 
</p></blockquote></div>

<div class="defun">
&mdash; structure option: <b>copier</b> [<var>name</var>]<var><a name="index-copier-351"></a></var><br>
<blockquote><p>This option controls the definition of a procedure to copy instances of
the structure.  This is a procedure of one argument, a structure
instance, that makes a newly allocated copy of the structure and returns
it.  If <var>name</var> is not given, the copier is defined, and the name
of the copier is <code>"copy-"</code> followed by the structure name (e.g. 
&lsquo;<samp><span class="samp">copy-foo</span></samp>&rsquo;).  If <var>name</var> is <code>#f</code>, the copier is not
defined.  Otherwise, <var>name</var> must be a symbol, and the copier is
defined with that symbol as its name. 
</p></blockquote></div>

<div class="defun">
&mdash; structure option: <b>print-procedure</b><var> expression<a name="index-print_002dprocedure-352"></a></var><br>
<blockquote><p>Evaluating <var>expression</var> must yield a procedure of two arguments,
which is used to print instances of the structure.  The procedure is an
<dfn>unparser method</dfn> (see <a href="Custom-Output.html#Custom-Output">Custom Output</a>).  If the structure
instances are records, this option has the same effect as calling
<code>set-record-type-unparser-method!</code>. 
<a name="index-set_002drecord_002dtype_002dunparser_002dmethod_0021-353"></a></p></blockquote></div>

<div class="defun">
&mdash; structure option: <b>constructor</b> [<var>name </var>[<var>argument-list</var>]]<var><a name="index-constructor-354"></a></var><br>
<blockquote><p><a name="index-BOA-constructor-_0028defn_0029-355"></a>This option controls the definition of constructor procedures.  These
constructor procedures are called &ldquo;<span class="sc">boa</span> constructors&rdquo;, for &ldquo;By
Order of Arguments&rdquo;, because the arguments to the constructor specify
the initial contents of the structure's slots by the order in which they
are given.  This is as opposed to &ldquo;keyword constructors&rdquo;, which
specify the initial contents using keywords, and in which the order of
arguments is irrelevant.

        <p>If <var>name</var> is not given, a constructor is defined with the default
name and arguments (see above).  If <var>name</var> is <code>#f</code>, no
constructor is defined; <var>argument-list</var> may not be specified in this
case.  Otherwise, <var>name</var> must be a symbol, and a constructor is
defined with that symbol as its name.  If <var>name</var> is a symbol,
<var>argument-list</var> is optionally allowed; if it is omitted, the
constructor accepts one argument for each slot in the structure
definition, in the same order in which the slots appear in the
definition.  Otherwise, <var>argument-list</var> must be a lambda list
(see <a href="Lambda-Expressions.html#Lambda-Expressions">Lambda Expressions</a>), and each of the parameters of the lambda
list must be the name of a slot in the structure.  The arguments
accepted by the constructor are defined by this lambda list.  Any slot
that is not specified by the lambda list is initialized to the
<var>default-init</var> as specified above; likewise for any slot specified
as an optional parameter when the corresponding argument is not
supplied.

        <p>If the <code>constructor</code> option is specified, the default constructor
is not defined.  Additionally, the <code>constructor</code> option may be
specified multiple times to define multiple constructors with
different names and argument lists.

     <pre class="example">          (define-structure (foo
                             (constructor make-foo (#!optional a b)))
            (a 6 read-only #t)
            (b 9))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; structure option: <b>keyword-constructor</b> [<var>name</var>]<var><a name="index-keyword_002dconstructor-356"></a></var><br>
<blockquote><p><a name="index-keyword-constructor-_0028defn_0029-357"></a>This option controls the definition of keyword constructor procedures. 
A <dfn>keyword constructor</dfn> is a procedure that accepts arguments that
are alternating slot names and values.  If <var>name</var> is omitted, a
keyword constructor is defined, and the name of the constructor is
<code>"make-"</code> followed by the name of the structure (e.g. 
&lsquo;<samp><span class="samp">make-foo</span></samp>&rsquo;).  Otherwise, <var>name</var> must be a symbol, and a keyword
constructor is defined with this symbol as its name.

        <p>If the <code>keyword-constructor</code> option is specified, the default
constructor is not defined.  Additionally, the
<code>keyword-constructor</code> option may be specified multiple times to
define multiple keyword constructors; this is usually not done since
such constructors would all be equivalent.

     <pre class="example">          (define-structure (foo (keyword-constructor make-bar)) a b)
          (foo-a (make-bar 'b 20 'a 19))         &rArr; 19
</pre>
        </blockquote></div>

<div class="defun">
&mdash; structure option: <b>type-descriptor</b><var> name<a name="index-type_002ddescriptor-358"></a></var><br>
<blockquote><p>This option cannot be used with the <code>type</code> or <code>named</code> options.

        <p>By default, structures are implemented as records.  The name of the
structure is defined to hold the type descriptor of the record defined
by the structure.  The <code>type-descriptor</code> option specifies a
different name to hold the type descriptor.

     <pre class="example">          (define-structure foo a b)
          foo             &rArr; #[record-type 18]
          
          (define-structure (bar (type-descriptor &lt;bar&gt;)) a b)
          bar             error--&gt; Unbound variable: bar
          &lt;bar&gt;         &rArr; #[record-type 19]
</pre>
        </blockquote></div>

<div class="defun">
&mdash; structure option: <b>conc-name</b> [<var>name</var>]<var><a name="index-conc_002dname-359"></a></var><br>
<blockquote><p>By default, the prefix for naming accessors and modifiers is the name of
the structure followed by a hyphen.  The <code>conc-name</code> option can be
used to specify an alternative.  If <var>name</var> is not given, the prefix
is the name of the structure followed by a hyphen (the default).  If
<var>name</var> is <code>#f</code>, the slot names are used directly, without
prefix.  Otherwise, <var>name</var> must a symbol, and that symbol is used as
the prefix.

     <pre class="example">          <code>(define-structure (foo (conc-name moby/)) a b)</code>
</pre>
        <p class="noindent">defines accessors <code>moby/a</code> and <code>moby/b</code>, and modifiers
<code>set-moby/a!</code> and <code>set-moby/b!</code>.

     <pre class="example">          <code>(define-structure (foo (conc-name #f)) a b)</code>
</pre>
        <p class="noindent">defines accessors <code>a</code> and <code>b</code>, and modifiers <code>set-a!</code> and
<code>set-b!</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; structure option: <b>type</b><var> representation-type<a name="index-type-360"></a></var><br>
<blockquote><p>This option cannot be used with the <code>type-descriptor</code> option.

        <p>By default, structures are implemented as records.  The <code>type</code>
option overrides this default, allowing the programmer to specify that
the structure be implemented using another data type.  The option value
<var>representation-type</var> specifies the alternate data type; it is
allowed to be one of the symbols <code>vector</code> or <code>list</code>, and the
data type used is the one corresponding to the symbol.

        <p>If this option is given, and the <code>named</code> option is not specified,
the representation will not be tagged, and neither a predicate nor a
type descriptor will be defined; also, the <code>print-procedure</code>
option may not be given.

     <pre class="example">          (define-structure (foo (type list)) a b)
          (make-foo 1 2)                          &rArr; (1 2)
</pre>
        </blockquote></div>

<div class="defun">
&mdash; structure option: <b>named</b> [<var>expression</var>]<var><a name="index-named-361"></a></var><br>
<blockquote><p>This is valid only in conjunction with the <code>type</code> option and
specifies that the structure instances be tagged to make them
identifiable as instances of this structure type.  This option cannot be
used with the <code>type-descriptor</code> option.

        <p>In the usual case, where <var>expression</var> is not given, the <code>named</code>
option causes a type descriptor and predicate to be defined for the
structure (recall that the <code>type</code> option without <code>named</code>
suppresses their definition), and also defines a default unparser method
for the structure instances (which can be overridden by the
<code>print-procedure</code> option).  If the default unparser method is not
wanted then the <code>print-procedure</code> option should be specified as
<code>#F</code>.  This causes the structure to be printed in its native
representation, as a list or vector, which includes the type descriptor. 
The type descriptor is a unique object, <em>not</em> a record type, that
describes the structure instances and is additionally stored in the
structure instances to identify them: if the representation type is
<code>vector</code>, the type descriptor is stored in the zero-th slot of the
vector, and if the representation type is <code>list</code>, it is stored as
the first element of the list.

     <pre class="example">          (define-structure (foo (type vector) named) a b c)
          (vector-ref (make-foo 1 2 3) 0) &rArr; #[structure-type 52]
</pre>
        <p>If <var>expression</var> is specified, it is an expression that is evaluated
to yield a tag object.  The <var>expression</var> is evaluated once when the
structure definition is evaluated (to specify the unparser method), and
again whenever a predicate or constructor is called.  Because of this,
<var>expression</var> is normally a variable reference or a constant.  The
value yielded by <var>expression</var> may be any object at all.  That object
is stored in the structure instances in the same place that the type
descriptor is normally stored, as described above.  If <var>expression</var>
is specified, no type descriptor is defined, only a predicate.

     <pre class="example">          (define-structure (foo (type vector) (named 'foo)) a b c)
          (vector-ref (make-foo 1 2 3) 0) &rArr; foo
</pre>
        </blockquote></div>

<div class="defun">
&mdash; structure option: <b>safe-accessors</b> [<var>boolean</var>]<var><a name="index-safe_002daccessors-362"></a></var><br>
<blockquote><p>This option allows the programmer to have some control over the safety
of the slot accessors (and modifiers) generated by
<code>define-structure</code>.  If <code>safe-accessors</code> is not specified, or
if <var>boolean</var> is <code>#f</code>, then the accessors are optimized for
speed at the expense of safety; when compiled, the accessors will turn
into very fast inline sequences, usually one to three machine
instructions in length.  However, if <code>safe-accessors</code> is specified
and <var>boolean</var> is either omitted or <code>#t</code>, then the accessors are
optimized for safety, will check the type and structure of their
argument, and will be close-coded.

     <pre class="example">          (define-structure (foo safe-accessors) a b c)
</pre>
        </blockquote></div>

<div class="defun">
&mdash; structure option: <b>initial-offset</b><var> offset<a name="index-initial_002doffset-363"></a></var><br>
<blockquote><p>This is valid only in conjunction with the <code>type</code> option. 
<var>Offset</var> must be an exact non-negative integer and specifies the
number of slots to leave open at the beginning of the structure instance
before the specified slots are allocated.  Specifying an <var>offset</var> of
zero is equivalent to omitting the <code>initial-offset</code> option.

        <p>If the <code>named</code> option is specified, the structure tag appears in
the first slot, followed by the &ldquo;offset&rdquo; slots, and then the regular
slots.  Otherwise, the &ldquo;offset&rdquo; slots come first, followed by the
regular slots.

     <pre class="example">          (define-structure (foo (type vector) (initial-offset 3))
            a b c)
          (make-foo 1 2 3)                &rArr; #(() () () 1 2 3)
</pre>
        </blockquote></div>

   <p>The essential differences between MIT/GNU Scheme's <code>define-structure</code>
and Common Lisp's <code>defstruct</code> are:

     <ul>
<li>The default constructor procedure takes positional arguments, in the
same order as specified in the definition of the structure.  A keyword
constructor may be specified by giving the option
<code>keyword-constructor</code>.

     <li><span class="sc">boa</span> constructors are described using Scheme lambda lists.  Since there
is nothing corresponding to <code>&amp;aux</code> in Scheme lambda lists, this
functionality is not implemented.

     <li>By default, no <code>copier</code> procedure is defined.

     <li>The side-effect procedure corresponding to the accessor <code>foo</code> is
given the name <code>set-foo!</code>.

     <li>Keywords are ordinary symbols &ndash; use <code>foo</code> instead of <code>:foo</code>.

     <li>The option values <code>false</code>, <code>nil</code>, <code>true</code>, and <code>t</code>
are treated as if the appropriate boolean constant had been specified
instead.

     <li>The <code>print-function</code> option is named <code>print-procedure</code>.  Its
argument is a procedure of two arguments (the unparser state and the
structure instance) rather than three as in Common Lisp.

     <li>By default, named structures are tagged with a unique object of some
kind.  In Common Lisp, the structures are tagged with symbols.  This
depends on the Common Lisp package system to help generate unique tags;
MIT/GNU Scheme has no such way to generate unique symbols.

     <li>The <code>named</code> option may optionally take an argument, which is
normally the name of a variable (any expression may be used, but it is
evaluated whenever the tag name is needed).  If used, structure
instances will be tagged with that variable's value.  The variable must
be defined when <code>define-structure</code> is evaluated.

     <li>The <code>type</code> option is restricted to the values <code>vector</code> and
<code>list</code>.

     <li>The <code>include</code> option is not implemented. 
</ul>

   </body></html>

